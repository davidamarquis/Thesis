% Optimization for fast compiling
% http://tex.stackexchange.com/questions/29324/how-do-i-speed-up-latex-compile-time
% enabling the draft setting in the documentclass should speed up compile time

% \RequirePackage[l2tabu, orthodox]{nag}
\documentclass{article}

% \usepackage{hyperref}

% should only 
\usepackage{anysize,amsfonts,amsmath,amsthm,amssymb,nicefrac,cite,url,setspace,xcolor,makeidx,float}
\usepackage[demo]{graphicx}
\usepackage[ruled,noline]{algorithm2e}

% http://stackoverflow.com/questions/1061112/eliminate-space-before-beginitemize
\usepackage{enumitem}
\setlist{nolistsep}

% http://tex.stackexchange.com/questions/162207/algorithm2e-comment-style
\newcommand\mycommfont[1]{\footnotesize\ttfamily\textcolor{black}{#1}}
\SetCommentSty{mycommfont}

% http://tex.stackexchange.com/questions/7650/centering-vdots-in-a-system-of-many-equations
% package lets you center ldots using \within or something
\usepackage{mathtools}

% http://tex.stackexchange.com/questions/2607/spacing-around-left-and-right
% fixing spacing on \left \right 
\let\originalleft\left
\let\originalright\right
\renewcommand{\left}{\mathopen{}\mathclose\bgroup\originalleft}
\renewcommand{\right}{\aftergroup\egroup\originalright}

\let\chapter\section
\bibliographystyle{plain}

%\marginsize{2cm}{2cm}{1cm}{1cm}

%
% Environments
%
\newenvironment{atxt}
  {\textup{\textbf\begin{quote}}}
  {\end{quote}}

%
% THMS ETC
%
\newcounter{dummy} \numberwithin{dummy}{section}
\theoremstyle{plain}
\newtheorem{thm}[dummy]{Theorem}
\newtheorem{prop}[dummy]{Proposition}
\newtheorem{cor}[dummy]{Corollary}
\newtheorem{lem}[dummy]{Lemma}
\theoremstyle{definition}
\newtheorem{mydef}[dummy]{Definition}

%
% MATH DEFS
%
\def\Fp {{ \mathbb{F} _ {p} }}
\def\Fq {{ \mathbb{F} _ {q} }}
\def\FP {{ \mathbb{F}^* _ {p} }}
\def\FQ {{ \mathbb{F}^* _ {q} }}
\def\FpE {{ \mathbb{F} _ {p^k} }}
\def\FqE {{ \mathbb{F} _ {q^k} }}
\def\FPE {{ \mathbb{F}^* _ {p^k} }}
\def\FQE {{ \mathbb{F}^* _ {q^k} }}
\def\mcA  {{ \mathcal{A}}} 
\def\mcB  {{ \mathcal{B}}} 
\def\mcS  {{ \mathcal{S}}} 
\def\mcT  {{ \mathcal{T}}}

%
% DEFS
%
% put this is alphabetical order as much as possible
\def\cons {{ \mathrm{constant} }}
\def\deg {{ \mathrm{deg}}}
\def\ind {{ \mathrm{ind} }}
\def\bind {{ \mathrm{ind}\hspace{1 mm} }}
\def\indd {{ \mathrm{ind_d} }}
\def\lcm {{ \mathrm{lcm} }}
\def\ord {{ \mathrm{ord} }}
\def\ords {{ \mathrm{ord \hspace{2pt}} }}
\def\poly {{ \mathrm{poly} }}
% I try to follow tex ideas with putting b in front to indicate that there should be space
\def\Res {{ \mathrm{Res}}}
\def\Refine {{ \mathrm{Refine}}}
\def\SpecialFac {{ \mathrm{SpecialFac}}}
\def\rad {{ \mathrm{rad}}}
% Only use the following if 
\def\indLa {{\ind (x) \left[l^0\right] }}
\def\indLb {{\ind (x) \left[l^1\right] }}
\def\indLc {{\ind (x) \left[l^i\right] }}
\def\indLd {{\ind (x) \left[l^{s-1}\right] }}
\def\indLat {{\ind (x^l) \left[l^0\right] }}
\def\indLbt {{\ind (x^l) \left[l^1\right] }}
\def\indLct {{\ind (x^l) \left[l^i\right] }}
\def\indLdt {{\ind (x^l) \left[l^{s-1}\right] }}

\makeindex

%
% START
%
\begin{document}
\pagenumbering{roman}
\begin{center}
    {\huge 
    Deterministic Factorization of Polynomials over Finite Fields}
    \vspace{1.5cm}

by\\

    \vspace{1cm}
{\large
David Marquis}

    \vspace{1.5cm}
A thesis submitted to the Faculty of Graduate and Post Doctoral Affairs in
partial fulfillment of the requirements for the degree of 

\vspace{1.5cm}

{\large
Master of Science
}

\vspace{1cm}

in\\

\vspace{1cm}

{\large
Pure Mathematics
}

\vspace{1.5cm}

Carleton University, Ottawa, Canada

\vspace{1.5cm}

\textcopyright 2014

\vspace{0.5cm}

David Marquis
\end{center}

\thispagestyle{empty}
\pagebreak

\doublespacing

\pagebreak
\section*{Abstract}
    We give new results for the problem of deterministically and unconditionally factoring polynomials over finite fields. We give efficient algorithms for the factorization of some odd degree polynomials over finite fields. We remove the assumption of the Extended Riemann Hypothesis from a well known algorithm for factoring polynomials over finite fields in the case that the degree of the polynomial to be factored is coprime to $\phi(p-1)$ where $p$ is the characteristic of the field and $\phi$ is the Euler totient function. We also give new results on the factorization of polynomials of bounded degree.
		
		Using new tools we give a concrete proof of a result in [\citenum{ronyai1988factoring}] that a polynomial of degree $n$ over the finite field $\Fp$ can be factored deterministically in a number of operations that is polynomial in $n^l$ where $l$ is the least prime factor of $n$ and $\log(p)$. 

\pagebreak
\section*{Acknowledgments}

\pagebreak
\pagenumbering{arabic}
\tableofcontents

%
% START
%
\newpage
\chapter{Introduction}
\label{CH:Introduction}
%
%
 
		In this thesis we are interested in algorithms that efficiently factor polynomials over finite fields. Factoring polynomials over finite fields (FPFF) has applications in computer algebra, coding theory, and cryptography.  A \emph{deterministic} algorithm that solves this problem was given by Berlekamp in [\citenum{berle1967}] and [\citenum{berlekamp1970factoring}]. The value of this algorithm is in its generality, any polynomial will eventually be factored by the algorithm, not in its efficiency. Over finite fields of large characteristic the algorithm is very slow as the number of operations needed to factor $f$ over $\Fq$ is not polynomial in $\deg(f)$ and $\log(q)$.

		Although an efficient and deterministic algorithm for FPFF does not yet exist there are efficient \emph{probabilistic} algorithms. A probabilistic algorithm is any algorithm that makes random choices. For many computational problems it has proved possible to construct probabilistic algorithms more easily then deterministic ones. Although there has been little progress on solving FPFF deterministically and unconditionally some progress has been made on this problem assuming conjectures such as the Riemann Hypothesis, or generalizations of it like the Extended Riemann Hypothesis, and the Generalized Riemann Hypothesis. We give new results on FPFF that are unconditional and deterministic in Chapter \ref{CH:uncond} and results that are deterministic under the Generalized Riemann Hypothesis in Chapter \ref{CH:ERH}.

		We make precise what we mean by factoring a polynomial. 

		\begin{mydef}
		\label{DEF:NONTRIVFACTOR}
		    Given a polynomial $f \in \Fq[X]$ then $g \in \Fq[X]$ is a nontrivial factor of $f$ if $g \mid f$ and $0<\deg(g)<\deg(f)$.  
		\end{mydef}

		\begin{mydef}
		\label{DEF:FACTOR}
		    To \emph{factor} a polynomial $f \in \Fq$ is to find a nontrivial factor of $f$.  
		\end{mydef}
		
		When a polynomial $h$ is a nontrivial factor of a polynomial $f$ we often abuse notation and simply refer to $h$ as a factor of $f$.   

		\begin{mydef}
		\label{DEF:COMPFACTORIZATION}
		To \emph{completely factor} a polynomial $f$ in $\Fq$ is to find irreducible polynomials $g_1,\ldots, g_k$ for positive integers $e_1,\ldots, e_k$ over $\Fq$ such that
		\[ f=\prod_{i=1}^k{{g_i}^{e_i}}. \] 
		\end{mydef}

		For us the problem of factoring polynomials over finite fields (FPFF) means an algorithm which takes a polynomial $f$ and factors it. An algorithm that is guaranteed to find a factor of a generic polynomial, such as Berlekamp's algorithm, can be extended to an algorithm to completely factor the polynomial simply by recursively applying the algorithm to each factor that is found. However, some of the literature on FPFF applies to particular classes of polynomials and has no relation to complete factorization algorithms. 
		
		In Chapter \ref{CH:Background} we discuss some well known facts which will be used in the rest of the thesis. Many of the results in this chapter deal with the \emph{index} (also known as the discrete log) of a finite field element and a generalization of it that we define for polynomials. The index of a polynomial gives a concrete way to understand many of the known results on FPFF. We also give some well known algorithms for FPFF in this section and some material on graph theory which is helpful (although not strictly necessary) for Chapter \ref{CH:uncond}.
		In Chapter \ref{CH:rFPFF} we survey some of the many results on FPFF. In Chapter \ref{CH:uncond} we first define five operations on polynomials $f$ and $g$ which factor as $f=\prod_{\alpha}{(X-\alpha)}$ and $g=\prod_{\beta}{(X-\beta)}$ in an algebraic closure of a finite field. These are
		% POW
		\[ f^{(k)} = \prod_{\alpha}({X-\alpha^k}), \]	
		% SUM DEF / QUO DEF
		\[ f \oplus g = \prod_{\alpha}{\prod_{\beta}({X-(\alpha+\beta)})}, 
	      \hspace{13 mm} 
		    f \ominus g = \prod_{\alpha}{\prod_{\beta}({X-(\alpha-\beta}))}, \]
	
    % PROD DEF / QUO DEF
		\[ f \otimes g = \prod_{\alpha}{\prod_{\beta}({X-\alpha\beta})}, 
	      \hspace{13 mm} 
		    f \oslash g = \prod_{\alpha}{\prod_{\beta}{(X-\frac{\alpha}{\beta})}}. \]
		These \emph{composed operations} are used to give several new results on FPFF that are deterministic. The results do not make use of any unproven conjectures. The most important new result in this section is an algorithm for factoring polynomials over the finite field $\Fp$ unconditionally and deterministically when $\gcd(n,\phi(p-1))=1$. The number of operations used is comparable to a well known result on factoring polynomials deterministically under the Extended Riemann Hypothesis. In Chapter \ref{CH:ERH} we give results on FPFF that require the assumption of the Extended Riemann Hypothesis and the Generalized Riemann Hypothesis. We use the composed operations as a concrete tool for proving a result given in [\citenum{ronyai1988factoring}] and [\citenum{gao}]. In the last chapter we give some open problems for further investigation. 
		
\newpage
\chapter{Background}
\label{CH:Background}
		
	  %
		% comp stuff
		%
		Some background knowledge will be assumed on the part of the reader. The reader should have some familiarity with finite fields and elementary number theory. This material is covered in [\citenum{FF}] Chapters 1 and 2. From the theory of computation the reader should be familiar with the basic ideas of the analysis of algorithms and using big-O notation for expressing the number of operations (or running time) of an algorithm. This material is covered near the beginning of [\citenum{von10modern}] or [\citenum{bach1996algorithmic}].
		
		%
		%
		%
		
		\subsection{Finite Fields Background}
		
		We start by giving the background results we need from finite fields and elementary number theory. We use the following notation. Let $x$ be a positive integer. Then $S(x)$ is the largest prime factor of $x$. Let $x$ and $y$ be positive integers. Then $\nu_y(x)$ is the largest power of $y$ dividing $x$. For example, if $x=75$ and $y=5$ then $\nu_y(x)=2$. We note that if $l$ is prime $\nu_l(xy)=\nu_l(x)+\nu_l(y)$. 
		
		The ring of univariate polynomials over a field $\Fq$ is denoted by $\Fq[X]$. This ring is a unique factorization domain. The finite field $\Fq$ has $q-1$ units and the multiplicative subgroup of its units is denoted $\FQ$. Every polynomial in this ring has unique factorization up to multiplication by a unit. 
		
    \begin{mydef}
		\label{DEF:pfield}
		    A \emph{prime field} is a finite field with a prime number of elements. If the number of elements is $p$ such a field is denoted by $\Fp$. 
		\end{mydef}
		
		\begin{thm}
		\label{THM:numElems}
		    Let $\mathbb{F}$ be a finite field of characteristic $p$. Then $\mathbb{F}$ has $p^k$ elements for some positive integer $k$. 
		\end{thm}
		
		\begin{thm}
		\label{THM:irreducs}
		    Let $p$ be a prime and $n$ be a positive integer. Every irreducible polynomial in $\Fp[X]$ of degree $n$ divides $X^{p^n}-X$.
		\end{thm}
		
		\begin{mydef}
		\label{DEF:splitting}
				Let $\Fq$ be a finite field and $f \in \Fq[X]$. An extension of $\FqE$ of $\Fq$ is called a \emph{splitting field} of $f$ if $f$ splits into a product of linear factors in $\FqE$ and $f$ has at least one irreducible factor of degree larger than one in any proper subfield of $\FQE$.  
		\end{mydef}
		
		\begin{thm}
		\label{THM:fuckingFields}
		    For every prime $p$ and positive integer $n$, there is a finite field with $p^k$ elements. Furthermore, this finite field is unique up to isomorphism.
		\end{thm}
		
		In particular, any finite field with $p^k$ elements is isomorphic to the splitting field $X^{p^k}-X$ over $\Fp$. 
		Let $f,g,h$ be polynomials and $f=g^k h$ where $\gcd(g,h)=1$ then $k$ is called the \emph{multiplicity} of $g$. If $k>1$ then $g$ is a multiple factor of $f$. A polynomial is called \emph{squarefree} if all its irreducible factors have multiplicity one.
		
		Given a polynomial $f$ of degree $n$ the \emph{reverse} of $f$ denoted $f^{*}$ is defined
		\[ f^{*} = X^n f \bigl(X^{-1} \bigr). \]
		
		\begin{thm}
		\label{THM:sqfIdea}
			Let $\FpE$ be a finite field, and $f$ be a degree $n$ polynomial over $\FpE$. If $\gcd(n,p)=1$ and $g \mid f$ then $f'$ is a polynomial of degree $n-1$ over $\FpE$ and $g^i \mid f$ if and only if $g^{i-1} \mid f'$. 
		\end{thm}

		Suppose we are given a degree $n$ polynomial $f$ over $\FpE$ such that $f=g_1g_2^{2}g_3^{3} \cdots g_k^{k}$ for polynomials $g_1,\ldots,g_k$ (possibly equal to 1) and $\gcd(n,p)=1$. Then for example, $g_2g_3^2 \cdots g_k^{k-1} = \gcd(f,f')$. Theorem \ref{THM:sqfIdea} is very important for the problem of factoring polynomials. It allows arbitrary polynomials to be decomposed into a product of polynomials that is squarefree. Algorithm \ref{ALGO:DistinctDegree} in Section \ref{SEC:AlgBack} produces such a decomposition. 
		
	  \begin{mydef}
		\label{DEF:DISCRIM}
		    Let $\Fq$ be a finite field. The \emph{discriminant} of a polynomial $f=(X-r_1)\cdots(X-r_n)$ over $\Fq$ is $\bigtriangleup(f) = \prod_{j=1}^n{ \prod_{i=1}^n{(r_i-r_j)} }$.
		\end{mydef}
		
		\begin{lem}
		\label{LEM:DISCRIMZERO}
		    Let $\Fq$ be a finite field and $f$ be a polynomial over $\Fq$. Then $\bigtriangleup(f)=0$ if and only if $f$ has a factor of multiplicity higher than one. 
		\end{lem}
				
		% phi(n) is used in the RH chapter
		For $n$ a positive integer $\phi(n)$ is the \emph{Euler totient function}, the number of positive integers less than $n$ that are coprime to $n$. If $n$ factors as $n=\prod_{i=1}^k{p_i^{e_i}}$ then 
		\[ \phi(n)=\prod_{i=1}^k{p_i^{e_i-1}(p_i-1)}. \]
		
		% some people would say multiplicative order
		The \emph{order}\index{order} of $x$ in $\FQ$ is the least positive integer such that $x^k=1$ and is denoted by $\ord(x)$. An element $x$ has order $d$ if and only if 
		\[ x^{d/r} \not= 1\]
		\noindent for each prime $r$ dividing $d$. The elements $x$ in $\Fq$ such that $\ord(x) = d$ are \index{primitive $d$th roots of unity} \emph{primitive $d$th roots of unity}. If $d=q-1$ then $x$ is called a \index{primitive root} \emph{primitive root}. 
		
		\begin{lem}
		\label{LEM:LOWERORD}
		    Let $\Fq$ be a finite field, $d$ be a positive integer, and $x \in \FQ$. Then 
				\[ \ord \left(x^d \right)=\frac{\ord(x)}{\gcd(\ord(x),d)}. \] 
		\end{lem}
		% I could take a proof of this from the number theory book
		
		For example, if $g$ is a primitive root in $\FQ$ and $l$ is a prime dividing $q-1$ then $\ord(g^l)=(q-1)/l$. 
		
		\begin{cor}
		\label{COR:ORDPOWER}
		    Let $\Fq,x$ be as in Lemma \ref{LEM:LOWERORD} and let $s=\nu_{l}(q-1)$ and $d=(q-1)/l^s$. Then 
				\[ \nu_l \bigl(\ord(x) \bigr)=\nu_l \left(\ord \left(x^d \right) \right). \]
		\end{cor}
		
		\begin{proof}
		    By Lemma \ref{LEM:LOWERORD} we have
		    \[ \nu_l \bigl(\ord(x) \bigr) = \nu_l \bigl(\ord(x) \bigr)-\nu_l \bigl(\gcd(\ord(x),d) \bigr). \]
				As no power of the prime $l$ divides $d$ there is also no power of $l$ dividing $\gcd(\ord(x),d)$ so 
				\[ \nu_l \bigl(\gcd(\ord(x),d) \bigr)=0. \]
		\end{proof}
				
		A class of polynomials that is particularly interesting are the cyclotomic polynomials. 
		
		\begin{mydef}
		\label{DEF:CYC}
		    Let $\Fq$ be a finite field, $m$ a positive integer and $k$ the least positive integer such that $q^k \equiv 1 \pmod m$. Let $M$ be the set of all primitive $m$th roots of unity in $\FQE$. The $m$th \emph{cyclotomic polynomial} is defined as $\Phi_m=\prod_{\alpha \in M}{(X-\alpha)}$. 
		\end{mydef}		
		Let $\omega$ be a primitive $m$th root of unity in $\mathbb{F}_{q^k}$ then
		    \[ \Phi_m=\prod_{\substack{i=1 \\ \gcd(i,m)=1}}^m{ \left(X-\omega^i \right)}. \]
		as $\omega^i$ is a primitive $m$th root of unity if and only if $i$ is coprime to $m$. From this equation it is clear that the degree of $\Phi_m$ is equal to $\phi(m)$. 
	
		For example, in $\Fq[X]$ the fifth cyclotomic polynomial is
		    \[\Phi_5=\frac{X^5-1}{X-1}=X^4+X^3+X^2+X+1.\]
		The proof of Lemma \ref{LEM:cycCos} is in Chapter 2 of [\citenum{FF}]. 	
		\begin{lem}
		\label{LEM:cycCos}
		    Let $\Fq$ be a finite field and $m$ be a positive integer. The coefficients of $\Phi_m$ are in $\Fq$. 
		\end{lem}
		Constructing the irreducible factors of cyclotomic polynomials is a problem of central importance in the theory of finite fields. A theorem we will give in the next chapter shows that these polynomials can be factored in deterministic polynomial time assuming a generalization of the Riemann Hypothesis. However, not much is known about factoring these polynomials unconditionally.
		
		The concept of the index of an element will play a central role in the rest of this thesis.
		% I give it in generality. Yeah.
		\begin{mydef} 
		\label{DEF:IND}
		    Let $x \in \Fq$ and $g \in \Fq$ then the \emph{index} of $x$ denoted $\ind(x)$ with respect to $g$ is the least $k$ such that $g^k = x$ in $\Fq$ assuming such a $k$ exists.
		\end{mydef}
		
		We remark that the index over the finite field $\Fq$ with $g,h$ elements of order $d$ in $\FQ$ satisfies 
		\begin{itemize}
		    \item $\ind_g(1)  \equiv 0 \pmod {d}$
		    \item $\ind_g(ab) \equiv \ind_g(a)+\ind_g(b) \pmod {d}$
		    \item $\ind_g(a) \equiv \ind_h(a) \cdot \ind_g(h) \pmod {d}$
		\end{itemize}
		\noindent for any $a,b \in \FQ$. From the first and second properties it is easy to see that $\ind_g(a)+\ind_g(a^{-1}) \equiv 0 \pmod {d}$.
		
		Now we generalize the index of an element to polynomials. 
		\begin{mydef} 
		\label{DEF:INDF}
		    Let $f$ be a polynomial in $\Fq[X]$ with roots $r_1,\ldots,r_n$ and $g \in \Fq$ then the \emph{index} of $f$ with respect to $g$ is	
		    \[ \ind(f)=\{ \ind(r_1),\ldots,\ind(r_n)\} \] 
		    \noindent where $\ind(r_1),\ldots,\ind(r_n)$ are computed with respect to $g$. 
		\end{mydef} 
		For example, let $\Fp$ be a finite field so that $p \equiv 1 \pmod {2^4}$ and $f = X^8+1$ (the 16th cyclotomic polynomial) then $f$ factors as 
		    \[ f=(X-\omega)(X-\omega^3)(X-\omega^5)(X-\omega^7)(X-\omega^9)(X-\omega^{11})(X-\omega^{13})(X-\omega^{15}) \]
		if we then compute $\ind(f)$ with respect to $\omega$ we have 
		\begin{alignat*}{2}
		    &\ind(f) &&= \{1,3,5,7,9,11,13,15 \}. 
		\end{alignat*}
		
		% example needs help
		For $x \in \Fq$ and for $l$ a prime dividing $q-1$ define $\ind(x)[l^k]$ be the $k$th digit of $\ind(x)$, computed with respect to some primitive root, expressed in base $l$ with the lowest digit defined as the 0th digit. For example, if $\ind(x)=13$ then $\ind(x)=1+2^2+2^3$ and $\ind(x)[2^0]=1,\ind(x)[2^1]=0.$ 
		 	
		For $f$ of degree $n$ with roots $r_1,\ldots,r_n$ define	
		    \[ \ind(f)[l^k]=\left\{ \ind(r_1) \left[l^k \right],\ldots,\ind(r_n)\left[l^k \right] \right\}. \] 
		There are many possible elements that we could compute $\ind(f)$ with respect to. The next lemma shows that certain equalities between the indexes of elements in $\ind(f)$ are not altered by the choice of element used to compute $\ind(f)$.  
		
		\begin{lem}
		\label{LEM:NOGEN}
		    Let $a,b$ be elements in $\FQ$, $l$ a prime dividing $q-1$, $k$ a positive integer, and $g_1,g_2$ elements in $\Fp$ of the same order. For $k<\nu_l(q-1)$ we have $\ind(a)[l^k]=\ind(b)[l^k]$ with $\ind$ computed with respect to $g_1$ if and only if $\ind(a)[l^k]=\ind(b)[l^k]$ with $\ind$ computed with respect to $g_2$.
		\end{lem}
				
		\begin{proof}
		    There exists some positive integer $i$ so that $g_1^i=g_2$. Suppose $i$ divides $q-1$ then $g_2$ would not have the same order as $g_1$ by Lemma $\ref{LEM:LOWERORD}$ so $i$ must be coprime to $q-1$. Then if $g_2^k=x$ we have $g_1^{ik}=x$. Let $a_1$ be $\ind(x)$ computed with respect to $g_1$, $b_1$ be $\ind(x)$ computed with respect to $g_1$, $a_2$ be $\ind(x)$ computed with respect to $g_2$, and $b_2$ be $\ind(x)$ computed with respect to $g_2$. Then $a_1=ia_2$ and $b_1=ib_2$. Hence $\ind(a_1)[l^k]=\ind(b_1)[l^k]$ if and only if $\ind(a_2)[l^k]=\ind(b_2)[l^k]$.
				
		\end{proof}
		
	  For the rest of this thesis we use the following convention. If $\Fq$ is a finite field and $x$ is an element in $\FQ$ then $\ind(x)$ is always computed with respect to a primitive root of $\Fq$. We apply Lemma \ref{LEM:NOGEN} in the following way. Let $\Fq$ be a finite field, $f$ be a polynomial of degree $n$ with distinct roots $R=\{ r_1,\ldots,r_n \}$, $l$ be a prime dividing $q-1$, $s=\nu_l(q-1)$, and $g_1$ and $g_2$ be elements of $\Fq$ of the same order. For each $0 \leq k \leq l-1$ and $0 \leq i \leq s-1$ let	
		\begin{alignat*}{2}
		    S_{i,k} &= \{ r\in R : \ind_{g_1}(r_j)\left[l^i\right] = k \} \\
		    T_{i,k} &= \{ r\in R : \ind_{g_2}(r_j)\left[l^i\right] = k \} 
		\end{alignat*}
		where $\ind_{g_1}$ denotes that $\ind$ is computed with respect to the element $g_1$. Then by Lemma \ref{LEM:NOGEN} for any $0 \leq i \leq s-1$ we have 	
		    \[ ( \#S_{i,0}, \ldots, \#S_{i,l-1} ) = ( \#T_{i,0}, \ldots, \#T_{i,l-1} ) . \]	
		
		Lemma \ref{LEM:leftShift} and Lemma \ref{LEM:comRoot} are about relating the indexes of algebraically related elements. For an element $x$ in a finite field $\Fq$ and a prime $l$ dividing $q-1$ let $s=\nu_2(q-1)$. It is often useful to consider $\ind(x) \equiv a_0 + a_1l + a_2l^2 + \cdots +a_{s-1}l^{s-1} \pmod {l^s}$ as an $s$-tuple. Then 
		    \[ \left[ \indLa,\ldots,\indLd \right] = \left[a_0,\ldots,a_{s-1} \right]\]
		\noindent for $a_i$ between 0 and $l-1$. A special case of this Lemma Lemma \ref{LEM:leftShift} is.
		    \[ \left[ \indLat,\ldots,\indLdt \right] =\left[0,a_0,\ldots,a_{s-2}\right]. \]
		\begin{lem}
		\label{LEM:leftShift}
		% LAST CHECK : Sep 12 2014 
		    Let $x \in \FQ$, $l$ a prime dividing $q-1$, $s=\nu_l(p-1)$, and $z=\ind(x)[l^i]$ for some $0 < i < s-1$ then for any $k$ such that $k+i \leq s-1$ we have $z=\ind(x^{l^k})[l^{k+i}]$.  
		\end{lem}
		
		\begin{proof}
		    We have $\ind(x) \equiv a_0+a_1l+\cdots+a_{s-1}l^{s-1} \pmod {l^s}$ and $\ind(x^{l^k})=l^k \cdot \ind(x)$. Multiplication by $l^k$ gives
				    \[ l^k \cdot \ind(x) \equiv l^k \left( a_0+a_1l+\cdots+a_{s-1}l^{s-1} \right) \equiv {a_0}l^{k}+{a_1}l^{1+k}+\cdots+a_{s-1-k}l^{s-1} \pmod {l^s}. \]	
				Hence $z=\ind(x^{l^k})[l^{k+i}]$.
				
		\end{proof}
		
		For example, let $g$ be a primitive root modulo a prime $p$, $x=g^{1+2^2}$, $i=1$, $k=1$. Then 
		\begin{alignat*}{5}
		  &\ind(x)[2^0]  ,&&\ind(x)[2^1]  ,&& \ldots,&& \ind(x)[2^2]   &&= [1,0,1] \\
		  &\ind(x^2)[2^0],&&\ind(x^2)[2^1],&& \ldots,&& \ind(x^2)[2^2] &&= [0,1,0] 
		\end{alignat*}
		Let $z=\ind(x)[2^k]$ then $\ind(x^{2^k})[2^{i+k}]=\ind(x^2)[2^2]=0=z$.
		
		\begin{lem}
		\label{LEM:comRoot}
		% LAST CHECK : Sep 12 2014 
		    Let $\Fq$ be a finite field, $l$ a prime dividing $q-1$, $s=\nu_l(p-1)$, $x_1,x_2 \in \FQ$ such that $x_1^l=x_2^l$. Then for $0 < k < s-2$ we have $\ind(x_1)[l^k]=\ind(x_2)[l^k]$.
		\end{lem}
		
		The idea of the proof is that $(x_1/x_2)^l = 1$ in $\Fq$ so $x_1 = \omega x_2$ for $\omega$ an $l$th root of unity. Then $\ind(x_1)=\ind(\omega)+\ind(x_2) \equiv \ind(x_2) + kl^{s-1}$ for some $k$ with $0<k<l$. 
		
		Lemma \ref{LEM:comRoot} is relevant to factorization of polynomials of the form $X^l-a$ for $a \in \FQ$. For example, if $r_1, r_2$ are roots of $X^l-a$ for $a \in \FQ$ then for $0 < k < s-2$ we have $\ind(x_1)[l^k]=\ind(x_2)[l^k]$.
		
		\begin{lem}
		\label{LEM:ordInd}
		    Let $\Fq$ be a finite field and $x \in \FQ$ then 
				\begin{itemize}
				\item $\ord(x)=\frac {q-1}{\gcd(\ind(x),q-1)};$
				\item Let $l$ be a prime dividing $q-1$, $s=\nu_l(q-1)$, $\ind(x)\equiv a_0+a_1l+\ldots+a_{s-1}l^{s-1} \pmod {l^s}$, and $t$ be the largest positive integer so that $a_0,\ldots,a_t$ are all zero. Then $\nu_l(\ord(x))=s-t$.
				\end{itemize}
		\end{lem}
		
		\begin{proof}
		    For the first result let $g$ be an arbitrary primitive root. Then $x=g^{\ind_g(x)}$. Lemma \ref{LEM:LOWERORD} gives that $\ord(x)=\ord(g)/\gcd(\ord(g),d)$. The result follows by taking $d=\ind(x)$. For the second result 
				\begin{alignat*}{2}
				&\nu_l \bigl(\ord(x) \bigr) &&= \nu_l \bigl(\ord(g) \bigr) - \nu_l \bigl(\gcd(\ind(x),\ord(g)) \bigr)                                 \\
				&               &&= \nu_l(q-1) - \nu_l \bigl(\gcd(\ind(x),q-1) \bigr)                                    \\
				&               &&= s - \nu_l \bigl(\gcd(\ind(x),q-1) \bigr) 
				\end{alignat*}
				and we have that $l^t$ is the largest power of $l$ dividing $\ind(x)$ so $\gcd(\ind(x),q-1)=l^t$.
		\end{proof}
		
    Computing the index of $x \in \Fq$ is also called the \emph{discrete log} computation. There is no polynomial time algorithm for computing either the index or the order of arbitrary elements of $\Fq$. However, some information about the index of a polynomial can be inferred without computing it directly. For example, consider a polynomial $f$ over $\Fp$ which is a product of linear factors and which satisfies $f=h(X^2)$ for some polynomial $h$. Then $f$ factors as
		\begin{alignat*}{2}
		    f &=(X^2-r_1^2)(X-r_2^2) \cdots(X-r_k^2)                    \\
				  &=(X-r_1)(X+r_1)(X-r_2)(X+r_2)\cdots(X-r_k)(X+r_k) 
		\end{alignat*}
		\noindent for some roots $r_1,\ldots,r_k$. Let $g$ be a generator of $\Fp$. Then $-1 = g^{(p-1)/2}$. Then for each $r_i$ there exists an $e_i$ so that $g^{e_i} \equiv r_i \pmod p$ and hence 	
		\[ f=\bigl(X-g^{e_1} \bigr) \bigl(X+g^{e_1+(p-1)/2} \bigr) \cdots \bigl(X-g^{e_k} \bigr) \bigl(X+g^{e_k+(p-1)/2} \bigr) .\]
		
		Now let $s=\nu_2(p-1)$ then $(p-1)/2=j2^{s-1}$ for some odd $j$ with $j \equiv a_0 + {a_1}2 + \cdots + a_{s-1}2^{s-1} \pmod {2^s}$. Hence 
		\begin{alignat*}{2}
		\ind(r_1) &=e_1+(p-1)/2=e_1+ \left( a_0 + {a_1}2 + \cdots + a_{s-1}2^{s-1} \right) 2^{s-1} \\
		          &\equiv e_1+{a_0}2^{s-1} \pmod {2^s}. 
		\end{alignat*}
		
		Consider $\ind(r_1)-\ind(-r_1) \equiv {a_0}2^{s-1} \pmod {2^s}$. Hence $\ind(r_1)\left[2^{s-1} \right] \not= \ind(-r_1) \left[2^{s-1}\right]$. We have found some information about the bits of $\ind(f)$ when $f$ is equal to $h(X^2)$ for some polynomial $h$.
		
		\begin{mydef} 
		\label{DEF:nonresidue}
		    Let $x \in \FQ$ and $m$ be a divisor of $q-1$. Then $x$ is an $m$th \emph{residue} if $\ind(x) \equiv 0 \pmod m$ (with the index computed with respect to some primitive root $g$). Otherwise $x$ is an $m$th \emph{nonresidue}. If $m=2$ then $x$ is also called a \emph{quadratic residue}.	
		\end{mydef}
		Let $g,h$ be primitive roots modulo $p$. By Lemma \ref{LEM:ordInd} $\ord(g)=(q-1)/\gcd(\ind_h(g),q-1)$ hence $\gcd(\ind_h(g),q-1)=1$. In particular, 
		\[ \ind_h(g) \not\equiv 0 \pmod l \] 
		\noindent for any $l$ dividing $q-1$. Recall the ``change of basis'' formula $\ind_g(a) \equiv \ind_h(a) \cdot \ind_g(h) \pmod {q-1}$. This implies that 
		\[ \ind_g(a) \equiv \ind_h(a) \cdot \ind_g(h) \pmod {l} \]
		\noindent for any prime $l$ dividing $q-1$. If $a$ is an $l$th residue with $\ind(a)$ computed with respect to $g$ then $\ind_g(a) \equiv 0 \pmod l$. As $\ind_g(h) \not\equiv 0 \pmod {l}$ it follows that $\ind_h(a) \equiv 0 \pmod l$. Hence $a$ is a $l$th residue regardless of which primitive root is used to compute $\ind(a)$. 
		
		The next theorem is important because it shows that the property of being an $m$th residue can be tested in polynomial time. 
		
		\begin{thm} 
		\label{THM:RES}
		    Let $a \in \FQ$ and $l$ be a divisor of $q-1$. Then 
				\begin{itemize}
				\item $a$ is a $l$th residue in $\FQ$ if and only if $a^{(q-1)/l}=1$; 
				\item the polynomial $X^l-a$ has a root in $\FQ$ if and only if $a$ is an $l$th residue.
				\end{itemize}
		\end{thm}
		
		\begin{proof}
		     Suppose $a$ is a $l$th residue, and $g$ is a primitive root of unity modulo $p$. There exists a positive integer $k$ so that $a=g^{lk}$. Let $b=g^k$ then $a^{(q-1)/l}=(b^l)^{(q-1)/l}=1$ by Fermat's little theorem.
				
				 Suppose $a^{(q-1)/l}=1$ then there exists an integer $i$ so that ${g^i}^{(q-1)/l}=1$. Let $s=\nu_l(q-1)$ then $q-1=kl^s$ for some $k$ that is not divisible by $k$. We have 
				 \[ {g^i}^{(q-1)l^{-1}}=g^{i(q-1)l^{-1}}=g^{ikl^{s-1}}=1 \]
				 and so the $\ord(g)=q-1$ divides $ikl^{s-1}$. Hence $i$ is divisible by $l$ so $a$ is an $l$th residue. This shows the first statement.
				
				Suppose $a$ is a $l$th residue, and $g$ is a primitive root of unity modulo $p$. There exists a positive integer $k$ so that $a=g^{lk}$. Then $g^k$ is a root of $X^l-a$. In the other direction suppose $X^l-a$ has a root $z$. Then $z=g^i$ for some $i$. Hence 
				\[ \ind \bigl( a \bigr)=\ind \bigl( ( g^i )^l \bigr)=l\cdot\ind \left( g^i \right) \equiv 0 \pmod l. \]
		\end{proof}
		
		\begin{lem}
		\label{LEM:NumRes}
		    Let $q$ be a prime power and $l$ be a divisor of $q-1$. The number of $l$th residues in $\FQ$ is $(q-1)/l$. 
		\end{lem}
		
		\begin{proof}
		    Any $l$th residue is a root of $g=X^{(q-1)/l}-1$ by Theorem \ref{THM:RES} and $g$ is squarefree by Theorem \ref{THM:sqfIdea}. Let \[ h=\prod_{i=1}^{l-1}{(X^{(q-1)/l}-\omega^i)}. \] We have the factorization $X^{q-1}-1=gh$. Hence $g \mid X^{q-1}-1$ and so $g$ has $(q-1)/l$ distinct roots in $\Fq$. 
		\end{proof}
		
		\begin{cor}
		\label{COR:resProb}
		    Let $q$ be a prime power and $l$ be a divisor of $q-1$. A random element of $\FQ$ is an $l$th residue with probability $1/l$.
		\end{cor}
		
		% this use to be close to the algorithm that uses it. Now it is far. Oh well
		\begin{lem}
		\label{LEM:ordProd}
				Let $\Fq$ be a finite field. Then $\alpha \in \Fq$ has order dividing $d$ in $\Fq$ if and only if $\alpha$ is a root of $X^d-1$ and we have the factorization. $X^d-1=\prod_{\ord(\alpha) \mid d}{(X-\alpha)}$. 
		\end{lem}
		
		With $d=\frac{p-1}{2}$ this Lemma \ref{LEM:ordProd} is used for polynomial factorization in [\citenum{berle1967}] and [\citenum{cantor1981new}]. As an example of Lemma \ref{LEM:ordProd} if $x$ is a quadratic residue then $\ord(x)$ divides $(p-1)/2$ and so $x$ is a root of $X^{(p-1)/2}-1$. 
		
		In Theorem \ref{THM:rootFinding} we will see how to reduce factorization of an arbitrary polynomial over the finite field $\mathbb{F}_{p^k}$ to factoring polynomials that are squarefree products of linear factors over $\Fp$. Hence this class of polynomials is particularly important in the study of deterministic algorithms for FPFF. We note that this reduction is too slow to be of use for probabilistic FPFF algorithms. As this class is used so often we define a subset \index{$L_n$} $L_n$ of $\FQ[X]$ as
		%
		% Keywords: Split, poly, L_n, Ln 
		%
		\[ L_n=\left\{ f : f=\prod_{i=1}^n{(X-a_i)} , a_i \in \FQ \right\}. \]
		The number of polynomials in $L_n$ is $(q-1)^n$ since there are $q-1$ choices for each root. 
		
		Many algorithms for FPFF work by finding an element that is not a unit in the ring $R=\Fq[X]/(f)$. If $\alpha$ is such an element and is nonzero then $\gcd(\alpha,f)$ is a nontrivial factor of $f$. If $f$ factors as $f=f_1^{e_1} \cdots f_k^{e_k}$ then the ring $R$ decomposes as a product of finite fields as
		\[R = \Fq[X]/(f) \cong \Fq[X]/\left(f_1^{e_1}\right) \oplus \cdots \oplus \Fq[X]/\left(f_k^{e_k}\right). \]
	
		Any element $\alpha$ of this ring can be expressed as a vector $(a_1,\ldots, a_k)$ with $a_i = \alpha \pmod {f_i^{e_i}}$. The $a_i$ are referred to as the \emph{components} of $\alpha$. 
		
		Elements of the form $X^k$ in $R$ often play a role in the algorithms discussed in this thesis because their components are powers of the roots of $f$. In particular, if $f$ is a polynomial in $L_n$ over a finite field $\Fq$ and $r$ is a root of $f$ then $r^k$ is a component of $X^k$ in $R$. 
			
		Given an element $\alpha$ in $R$ with $f$ a polynomial in $L_n$ we sometimes need to compute the polynomial that has the components of $\alpha$ as its roots. Let $\Fq$ be a finite field, $f$ be a squarefree polynomial in $L_n$ with roots $r_1,\ldots,r_n$, $R=\Fq[X]/(f)$, and $\alpha \in R$. The element $\alpha$ is a polynomial of degree less than $n$ and has a tuple of components $(\alpha_1,\ldots,\alpha_n)$ with $\alpha_i$ equal to $\alpha$ evaluated at $r_i$. The \emph{minimal polynomial} of $\alpha$ is defined 
		\[ M_{X}(\alpha)=(X-\alpha_1) \cdots (X-\alpha_n) .\]
		The \emph{Berlekamp subalgebra} $B$ is the subring of $R=\Fq[X]/(f)$ such that an element of $R$ is in $B$ if and only if all its components are in $\Fq$. We note that over the finite field $\FpE$ the Berlekamp subalgebra is defined by some authors as the elements of $R$ with all their components in $\Fp$. The Berlekamp subalgebra is used in many results on factoring polynomials over finite fields. The next theorem is a useful equivalent characterization of the Berlekamp subalgebra. 
				
		\begin{thm}
		\label{THM:inBerle}
		    Let $\Fq$ be a finite field and $a \in \Fq[X]/(f)$ then $a$ is an element of the Berlekamp subalgebra if and only if $a^q=a$. 
		\end{thm}
		
		In the remainder of this section we discuss resultants. Resultants will be one of our main tools in the new algorithms we give in Chapter \ref{CH:uncond} and Chapter \ref{CH:ERH}.
		
		% to be precise it is 7.4.4
		Let $\mathbb{F}$ be a field and $f=\sum_{i=0}^n{a_iX^i}$ for some $a_0,\ldots,a_n$ in $\mathbb{F}$ and $g=\sum_{i=0}^m{b_iX^i}$ for some $b_0,\ldots,b_m$ in $\mathbb{F}$. The \emph{Sylvester matrix} is defined	
      \[M=
      \begin{pmatrix}
          a_0    &        &        &         & b_0     &          &          &        \\
          a_1    & a_0    &        &         & b_1     & b_0      &          &        \\
					a_2    & a_1    & \ddots &         & b_2     & b_1      & \ddots   &        \\
					\vdots & a_2    & \ddots & a_0     & \vdots  & b_2      & \ddots   & b_0    \\
					a_n    & \vdots & \ddots & a_1     & b_m     & \vdots   & \ddots   & b_1    \\
					       & a_n    &        & \vdots  &         & b_m      &          & \vdots \\
								 &        &        & a_n     &         &          &          & b_m    \\
      \end{pmatrix}
  		\]	
			\noindent where the empty positions are filled with zeroes. The Sylvester matrix is illustrated by the following example for two polynomials of degree 5 and 3.	
			\[
      M=
      \begin{pmatrix} 
            a_0 & 0   & 0   & b_0   & 0   & 0   & 0   & 0  \\
            a_1 & a_0 & 0   & b_1   & b_0 & 0   & 0   & 0  \\
					  a_2 & a_1 & a_0 & b_2   & b_1 & b_0 & 0   & 0  \\
					  a_3 & a_2 & a_1 & b_3   & b_2 & b_1 & b_0 & 0  \\
					  a_4 & a_3 & a_2 & 0     & b_3 & b_2 & b_1 & b_0\\
					  a_5 & a_4 & a_3 & 0     & 0   & b_3 & b_2 & b_1\\
					  0   & a_5 & a_4 & 0     & 0   & 0   & b_3 & b_2\\
					  0   & 0   & a_5 & 0     & 0   & 0   & 0   & b_3
			\end{pmatrix}
      .\]
		\begin{mydef} 
				\label{DEF:ResDef}
				Let $R$ be a unique factorization domain with field of fractions $F$, $f,g \in R[X]$ monic nonzero polynomials of degrees $n$ and $m$, respectively, and $\alpha_1,\ldots,\alpha_n$ and $\beta_1,\ldots, \beta_n$ the roots of $f$ and $g$, respectively, in an extension of $F$, counted with multiplicities 

				The \emph{resultant} of $f$ and $g$ with respect to the indeterminant $X$ is defined as

				\[ \Res_{X}(f,g)=\prod_{i=1}^n {\prod_{j=1}^n { ( \alpha_i-\beta_j ) }  } \]
		\end{mydef}
		
		This definition follows [\citenum{von10modern}] Chapter 6. For example, let $f=X-Y$ and $g=X-Y^2 $ then $\Res(f,g,X)=Y-Y^2$.
		
		The most useful property of the resultant is that it can be computed on polynomials without given factorizations. It can be computed as the determinant of the Sylvester matrix or using a variation of the Euclidean algorithm [\citenum{von10modern}]. 	
		
		\begin{thm}
		\label{THM:rescomp}
		    Let $\mathbb{F}$ be a field and $f=\sum_{i=0}^n{a_iX^i}$ for some $a_0,\ldots,a_n$ in $\mathbb{F}$ and $g=\sum_{i=0}^m{b_iX^i}$ for some $b_0,\ldots,b_m$ in $\mathbb{F}$ with Sylvester matrix $M$. Then
		    \[ \Res_{X}(f,g)=\det(M) \]
		\end{thm}
				
		%
		%
		%
		%
		%
		\subsection{Algorithmic Background}
		\label{SEC:AlgBack}
		
		The running times of algorithms in this thesis are given in terms of $\Fp$-\emph{operations}. An $\Fp$-operation is one of the operations $(+,-,*,\div)$ in the finite field $\Fp$ where $p$ is a prime. For the rest of this thesis, whenever we refer to the number of operations of an algorithm we mean the number of $\Fp$-operations. 
		
		It is easiest to compute the running time of an algorithm which has input in the finite field $\mathbb{F}_{p^k}$ in two steps: first, compute the number of $\mathbb{F}_{p^k}$ operations that are used. We can take $\mathbb{F}_{p^k}=\Fp[X]/(f)$ for an irreducible polynomial $f$ of degree $k$. The elements of $\mathbb{F}_{p^k}$ can be treated as polynomials of degree less than $k$. The operations $(+,-,*,\div)$ on two elements of $\mathbb{F}_{p^k}$ can then be performed in $O(k)$ $\Fp$-operations for $+$ and $-$ and $O(k^2)$ $\Fp$-operations for $*$ and $\div$ by performing the addition, subtraction, multiplication, or division of two elements of $\mathbb{F}_{p^k}$ in the straightforward way and then computing the remainder of the result after being divided by $f$. Hence an algorithm that uses $O(L)$ $\mathbb{F}_{p^k}$-operations uses $O(Lk^2)$ $\Fp$-operations. 
		
		We note that another way to state running times of finite field algorithms is in terms of \emph{bit operations}. A bit operation is a logical XOR or AND operation on two bits. For example, [\citenum{bach1996algorithmic}] uses this style. The four $\Fp$ operations given above can be computed in $O(\log(p))$ bit operations for $+$ and $-$, and $O(\log(p)^2)$ bit operations for $*$ and $\div$. 
		
		An algorithm $f$ uses $\poly(a_1,\ldots,a_k)$ operations if there is some polynomial upper bound in the parameters $a_1,\ldots, a_k$ on the number of operations. For example, Berlekamp's algorithm could be said to use $\poly(q, n)$ operations. 

		In this thesis an algorithm is called \emph{polynomial time} if the number of $\Fp$-operations used by the algorithm is polynomial in the length of the input.  For example, to store a polynomial of degree $n$ over $\Fp$ requires storing the $n+1$ coefficients which are integers between $0$ and $p-1$. An integer in this range could have $O(\log(p))$ bits so the input size for the whole polynomial is $O(n\log(p))$. Similarly, for the finite field $\Fq$ a polynomial has a length of $O(n \log(q))$ bits. Berlekamp's algorithm requires $O(q)$ gcd computations of elements of $\Fq[X]$ in the worst case so the number of operations used is proportional to $q$. There is no polynomial function of $O(n \log(q))$ that could upper bound $q$ so this algorithm is not polynomial time. 
		
		In the next chapter some results are stated using soft-O notation. The expression $f(n)=\tilde{O}(g(n))$ is shorthand for 
		\[ f(n) = O \Bigl(g(n) \log \bigl(g(n) \bigr)^k \Bigr) \] 
		\noindent for any positive integer $k$. 
		
		%By a reduction between two computational problems $A$ and $B$ we mean a Turing reduction. Intuitively this means that given an algorithm for computing a solution to $B$ a solution for any instance of $A$ can be recovered. 
		
		% there is no point in generality for anything except the theorems I need 
		\begin{lem}
		\label{LEM:primrootConstruction}
		    Let $\mathbb{F}_{p^k}$ be a finite field, $q=p^k$, $l$ a prime dividing $q-1$, and $s=\nu_l(q-1)$. Then given an $l$th nonresidue we can construct an $l^s$ primitive root of unity in $O(\log(q)k^2)$ operations. 
		\end{lem}
		
		\begin{proof}
		    We have that $m=(q-1)/l^s$ is not divisible by $l$. Let $x$ be an $l$th nonresidue and $y=x^m$. Then $\ind(x) \equiv a_0+a_1l+a_2l^2+ \cdots +a_{s-1}l^{s-1} \pmod{l^s}$ where $0 \leq a_i < l$ and $a_0 \not=0$. Then
				
				\[ \ind(y) \equiv m \left(a_0+{a_1}l+{a_2}l^2+\cdots+a_{s-1}l^{s-1} \right)
				\equiv ma_0 \not=0 \pmod{l} \]
				
				\noindent so $y$ is an $l$th nonresidue and hence the order of $y$ is divisible by a power of $l^s$. On the other hand for any prime $r$ dividing $p-1$ we have that $\ind(x) \equiv 0 \pmod{r}$. Hence the order of $y$ is a power of $l$ and so $y$ must be an $l^s$ primitive root of unity.
				
				We now consider the number of operations. Suppose $\Fq$ is given as $\Fp[X]/(g)$ for some polynomial $g$ of degree $k$. Computation of $y$ takes $O(\log(q))$ multiplications in $\Fq$ using a simple repeated squaring algorithm. Each multiplication can be performed as the multiplication of two polynomials of degree less than or equal to $k$ followed by a division by $g$. Both multiplication and division of polynomials of degree less than or equal to $k$ take $O(k^2)$ operations. 
		\end{proof}
		
	  When attempting to factor a polynomial efficiently over a finite field $\Fq$ it may be useful to use fast algorithms for polynomial multiplication such as Karatsuba or FFT based algorithms. However, since the problem of \emph{deterministically} factoring polynomials over finite fields is of theoretical interest, to make expressions for the number of operations of an algorithm simpler and more concise we will assume a straightforward algorithm for polynomial multiplication is used when considering the number of operations of our algorithms.
				
		% These easy time bounds are used in some of the basic theorems on poly factorization. In these cases working in R defined in THM runtimes is unnec. 
		\begin{thm}
		\label{THM:EASYTIMES}
		    Let $\FpE$ be a finite field. 
				\begin{itemize}
				    \item Multiplication and division of two polynomials in $\FpE[X]$ of degree at most $n$ can be performed using $O((nk)^2)$ $\Fp$-operations. 
				    \item Let $f$ and $g$ be polynomials in $\FpE[X]$ of degree at most $n$. Then $f \pmod g$ can be computed using $O((nk)^2)$ $\Fp$-operations.
				    \item The greatest common divisor of two polynomials in $\FpE[X]$ of degree at most $n$ can be performed using $O((nk)^2)$ $\Fp$-operations. 
				\end{itemize}
		\end{thm}
		
		Earlier we saw that if a polynomial $f$ factors as $f=f_1^{e_1} \cdots f_k^{e_k}$ over the finite field $\Fq$ then the ring $\Fq[X]/(f)$ decomposes as a product of finite fields
		\[\Fq[X]/(f) \cong \Fq[X]/\left(f_1^{e_1}\right) \oplus \cdots \oplus \Fq[X]/\left(f_k^{e_k}\right). \]
		We now consider the number of operations needed to compute in this ring. We recall that if an element $\alpha$ in $\Fq[X]/(f)$ is not a unit then $\gcd(\alpha,f)$ is a factor of $f$. 
		
		% TO DO: needs to be rewritten to be in terms of field operations
		\begin{thm} 
		\label{THM:runTimes}
		    Let $f$ be a nonzero polynomial in $\FpE[X]$ of degree $n$, $R =\FpE[X]/(f)$. 
				\begin{itemize}
		        \item Addition and subtraction of elements in $R$ can be performed using $O(nk)$ $\Fp$-operations. 
		        \item Multiplication of elements in $R$ can be performed using $O(( nk )^2)$ $\Fp$-operations. 
		        \item Inversion of elements in $R^{*}$ can be performed using $O(( nk )^2)$ $\Fp$-operations. 
		        \item Exponentiation of elements in $R$ to the power $e$ can be performed using $O(\log(e)(nk)^2)$ \\
						$\Fp$-operations.
				\end{itemize}
		\end{thm}
		
		In some results on FPFF it is necessary to find a basis for the Berlekamp subalgebra. To construct a basis of the Berlekamp subalgebra of $R=\Fq[X]/(f)$ where $f$ is a polynomial of degree $n$ we form a matrix $M$ with rows $m_1,\ldots,m_n$ with $m_i$ defined 
		\[ m_i=(a_0,\ldots,a_{n-1}) \]
		\noindent for $a_j \in \Fq$ such that 
		\[ \bigl(X^i\bigr)^q = \sum_{i=0}^{n-1}{a_iX^i} \]
		(computing $(X^i)^q$ is done in $R$). Then we find the kernel of $M-I$. For example, a basis for the Berlekamp subalgebra of $\mathbb{F}_{19}[X]/(f)$ with $f=X^4+X^3+X^2+X+1$ is found by computing
		\begin{alignat*}{3}
		    &X^{p}  = \bigl( X^5 \bigr)^3 X^4 = X^4               &&= -\bigl( X^3+X^2+X+1 \bigr)  \\
				&X^{2p} = \bigl(X^p \bigr)^2 = \bigl( X^4 \bigr)^2 &&= X^3 \\
				&X^{3p} = \bigl(X^p \bigr)^3 = \bigl( X^4 \bigr)^3 &&= X^2 
		\end{alignat*}
		\noindent using the fact that $X^5=1.$ Then the matrix is
      \[M=
      \begin{pmatrix}
          1     &  0    &  0     & 0     \\
          -1    & -1    & -1     & -1    \\
		      0     &  0    & 0      & 1     \\			
		      0     &  0    & 1      & 0     \\			
      \end{pmatrix}
			.\]
		A basis for the kernel of $M-I$ is $\{ [-2\hspace{2mm}0\hspace{2mm}1\hspace{2mm}1]^T,[-2\hspace{2mm}1\hspace{2mm}0\hspace{2mm}0]^T \}$ so any element in the span of these vectors is in the Berlekamp subalgebra. 
		
		% Theorem \ref{THM:BERLEBASIS} is proved in [\citenum{bach1996algorithmic}] Chapter 7.
		\begin{thm} 
		\label{THM:BERLEBASIS}
		    Let $\FpE$ be a finite field, $f$ a degree $n$ polynomial in $\FpE[X]$, and $R = \FpE[X]/(f)$, and let $B$ denote the Berlekamp algebra of $R$ considered as a $\FpE$-vector space. A basis for $B$ can be found using $O((\log(q)+nk)n^2k^2)$ operations. 
		\end{thm}
		
		\begin{proof}
		    There are two computational steps that are involved. The first is constructing the set of powers $X^q,\left(X^{q} \right)^2,\ldots,\left(X^{q} \right)^{n-1}$. One way to perform this calculation is to compute $X^q$ modulo $f$ and then get the rest of the powers by performing $n$ multiplications. These steps take $O(\log(q)(nk)^2)$ and $n(nk)^2$ operations respectively by Theorem \ref{THM:runTimes}. The next step involves finding the kernel of the $M-I$. This can be done using the elementary operations of adding rows of the matrix, multiplying rows of the matrix by elements of $\Fq$ and swapping rows of the matrix to perform Gaussian elimination. Elimination takes $O((nk)^3)$ operations. 
		\end{proof}	
		We note that when $f$ splits into a product of linear factors the Berlekamp subalgebra of $R = \Fq[X]/(f)$ is equal to $R$. 
		
		We now discuss some of the algorithms used for factoring polynomials over finite fields. Many algorithms for polynomial factorization proceed in three stages. 
		\begin{itemize}
		    \item Squarefree Factorization: The squarefree factors of $f$ are found.
				\item Distinct Degree Factorization: The squarefree factors of $f$ are factored in products of irreducible polynomials of equal degree.
				\item Equal Degree Factorization: The distinct degree factors of $f$ are factored into irreducibles. 
		\end{itemize}
		Algorithm \ref{ALGO:SQFDECOMP} is a squarefree factorization algorithm. 
		
		\begin{singlespace}
		\begin{algorithm}[H] 
		\DontPrintSemicolon
		\label{ALGO:SQFDECOMP}
		\caption{SQF\_DECOMP}
				Input: $\Fq,f$ \;
				\hspace{2mm} $\Fq$ a finite field \;
				\hspace{2mm} $f$ a polynomial in $\Fq[X]$ with factorization $f=\prod_{i=1}^k{f_i^{e_i}}$ with $0<e_1<e_2<\cdots<e_k$ \;
				Output: a list of pairs of the form $[f_i,e_i]$ for $i=1,\ldots,k$ \;
				\;
		    $g=\gcd(f,f')$ \;
		    \If{$f'=0$}{ 
		        find $h$ so that $h^p=f$ \;
				    $[[h_1,e_1],\ldots,[h_s,e_s]]$ = SQF\_DECOMP($h$) \;
		    }
	      \Else{
		        \If{$g=1$}{
		            Return $[[f,1]]$ \;
						}
		        \Else{
		            Return [SQF\_DECOMP($g$),SQF\_DECOMP($f/g$)] \;
				    }
        }
    \end{algorithm}
		\end{singlespace} 
		\vspace{5mm}		
		Algorithm \ref{ALGO:DistinctDegree} is a distinct degree factorization algorithm. It makes use of Theorem \ref{THM:irreducs}. From this theorem we have that every irreducible polynomial of degree $n$ over the finite field $\Fq$ divides the polynomial $X^{q^n}-X$. In Algorithm \ref{ALGO:DistinctDegree} given a finite field $\Fq$ we define
		\[ \tau(x)=x^q\] 
    \noindent for $x \in \Fq[X]/(f)$. 

    \begin{singlespace}
		\begin{algorithm}[H] 
		\DontPrintSemicolon
		\label{ALGO:DistinctDegree}
		\caption{DIS\_DEG}
		    Input: $\Fq,f$ \;
				\hspace{2mm} $\Fq$ a finite field \;
				\hspace{2mm} $f$ a squarefree polynomial in $\Fq[X]$ \;
		    Output: a list $M$ of factors of $f$ in $\Fq$ such that each factor is a product of irreducible polynomials of equal degree \;
				\;
		    $g=X$ \;
		    Initialize $M$ as an empty tuple \;
		    \For{$i=1 \ldots \deg(f)$}{ 
			      $g=\tau(g)$ \;
			      $f_i=\gcd(g-X,f)$ \;
			      Add $f_i$ to $M$ \;
			     $f=f/f_i$ \;
		    }
		    Return $M$ \;
		\end{algorithm}
		\end{singlespace}
		\vspace{5mm}	
				
		Our interest in this thesis is purely in deterministic algorithms for FPFF. We give Algorithm \ref{ALGO:cz} as an example of a \emph{probabilistic} algorithm for equal degree factorization. This algorithm is polynomial time. The main idea of the algorithm is that for any element $\alpha$ in the Berlekamp subalgebra of $\Fq[X]/(f)$ we have ${\alpha}^{q}=(\alpha,\ldots,\alpha)$ so ${\alpha}^{{q-1}/2}=(\pm 1,\pm 1, \ldots, \pm 1)$. Hence it is likely that the vector ${\alpha}^{{q-1}/2}$ is not equal to all 1s or -1s. 
		
		\begin{singlespace}
		\begin{algorithm}[H]
		\DontPrintSemicolon
				\label{ALGO:cz}
				\caption{DIS\_DEG}
				Input: $\Fq,f$ \;
				\hspace{2mm} $\Fq$ a finite field \;
				\hspace{2mm} $f$ a squarefree polynomial in $\Fq[X]$ \;
				Output: A nontrivial factor of $f$ \;
				\;
				Contruct a random $\alpha$ in the Berlekamp subalgebra of $\Fq[X]/(f)$ \;
				$g = \gcd(f,\alpha)$ \;
				\If{ $0 < \deg(g) < \deg(f)$}{ 
				  \tcc{check that $\alpha$ does not have any components that are zero}
					Return $g$ \;
				}
				$\beta = {\alpha}^{(q-1)/2}$\;
				$g = \gcd(\beta - 1, f)$\;

				\If{$0 < \deg(g) < \deg(f)$}{
					Return $g$ \;
				}
				\Else{
				  Return FAIL;
				}
		\end{algorithm}
		\end{singlespace}
		\vspace{5mm}	
		
		The algorithm is not guaranteed to produce a factor but if it returns failure it can be repeated until a factor is discovered. We note that although Algorithm \ref{ALGO:cz} is given as an example of an equal degree factorization algorithm, this algorithm will produce a factor of any squarefree polynomial.
		
		Due to the fact that Algorithm \ref{ALGO:SQFDECOMP}, and Algorithm \ref{ALGO:DistinctDegree} are deterministic polynomial time algorithms, when we are considering the problem of \emph{deterministic} polynomial factorization we may as well assume that the polynomials we wish to factor are squarefree products of irreducible polynomials of the same degree.  
		
		The next theorem reduces the problem of factoring polynomials over $\Fq$ to finding roots of polynomials of over $\Fp$. This theorem is too slow to be used by probabilistic algorithms for factoring polynomials but it is a useful simplification for factoring polynomials deterministically. 

		\begin{thm} 
				\label{THM:rootFinding}
				Let $p$ be a prime, $q=p^k$, $f$ a polynomial of degree $n$ in $\Fq[X]$, and assume $f$ has $i$ irreducible factors for $i \geq 2$. Then there are a pair of polynomials $g\in \Fq[X]$ and $h \in \Fp[X]$ with the following properties 
				\begin{itemize}
				    \item $h$ splits completely in $\Fp[X]$;
				    \item for any root $a$ of $h$ in $\Fp$, $\gcd(g - a, f)$ is a nontrivial factor of $f$; 
				    \item $\deg(g) < n$;
				    \item $\deg(h) = i$.
				\end{itemize}
				These polynomials can be computed using $O((nk)^3)$ $\Fp$-operations. 
		\end{thm}
		% there are 2 parts to the proof
		% part 1: compute 1 resultant
		% part 2: compute the polynomial defined in H and N
		
		The idea of the proof is that given $f$ a polynomial over $\Fq$ in the indeterminant $X$ we should choose an element $g(X)$ in Berlekamp subalgebra generated by $f$. Then there exists some $c \in \Fp$ so that $g-c$ and $f$ have a common factor. Recalling the earlier definition of the resultant we have the values of $c$ such that $\gcd(f,g-c)=0$ are the roots of the polynomial $h(Y)=\Res(f,g-Y)$ where the resultant is computed with respect to $X$. To factor $f$ over $\Fq$ it suffices to find a root of $h$ over $\Fq$. Root finding over $\Fq$ may be reduced to root finding over $\Fp$ as is explained in [\citenum{FF}] Chapter 4.
		
		Much of the remainder of this chapter will be spent on two algorithms for factoring polynomials in $L_n$ (products of linear factors of degree $n$) over a finite field $\Fq$. These are Algorithm \ref{ALGO:diffords} and Algorithm \ref{ALGO:INDFAC}. We also consider computing a type of congruence involving $\ind(x)$ for $x$ an element of a finite field. We connect this to a special case of factoring polynomials over finite fields; finding roots of polynomials of the form $X^n-a$ for $a \in \Fq$. 
		
		Algorithm \ref{ALGO:diffords} factors any polynomial which has two roots of distinct order. It is interesting because it is deterministic and is not conditional on any unproven conjectures. However, it requires a list of prime factors of $q-1$ which cannot be computed in deterministic polynomial time in $\log(q)$. It is also difficult to know in advance whether a polynomial does have roots of distinct order. Algorithm \ref{ALGO:diffords} is easily derived from known results however it does not seem to have been stated explicitly before. 
		\begin{singlespace}
		\begin{algorithm}[H]
		\DontPrintSemicolon
    \label{ALGO:diffords}
		\caption{DIFF\_ORDS}
		Input: $\Fq,F,f$ \;
		\hspace{2mm} $\Fq$ a finite field \;
		\hspace{2mm} $F$ a list of the prime factors of $q-1$ \; 
		\hspace{2mm} $f \in L_n$ over $\Fq$ such that $f$ is squarefree \;
		Output: A factor of $f$\;
		    \;
				let $R=\Fq[X]/(f)$ \;
				\For{$l \in F$}{
		        $s=\nu_l(q-1)$ \;
				    $d=(q-1)/l^s$ \;
						\tcc{note that $\alpha$ is an element of $R$ so $X^d$ is reduced modulo $f$} \;
		        $\alpha=X^d$ \;
						\tcc{note that $\alpha^{l^s}=1$ so the following while loop terminates after $s$ iterations}
				    \While{$\alpha \not\in \Fq$}{
				        $\beta=\alpha$ \;
						    $\alpha=\alpha^l$ \;
								\If{$0<\gcd(\beta-1,f)$ \textup{\textbf{and}} $\gcd(\beta-1,f)<n$}{
								    Return $\gcd(\beta-1,f)$ \;
								}
				    }
				}
    \end{algorithm}
		\end{singlespace}
		\vspace{5mm}	
							
		For example, let $f=(X-1)(X+1)=X^2-1$ and $p=7$. Clearly 1 and -1 have different orders $\pmod p$. Let $l=2$ then $\nu_2(p-1)=1$. Let $d=(p-1)/2$ we find that $\alpha=X^d \pmod {\langle f,p \rangle} \not\in \Fp$. Then we can get a factor of $f$ by computing $\gcd(f,X^d-1)=\gcd(f,X^3-1 \pmod f)=\gcd(X^2-1,X-1)=\gcd(X^2-1, X-1)=X-1$.
		
		\begin{thm}
		\label{THM:diffOrds}
				Let $\FpE$ be a finite field, so that the prime factorization of $p^k-1$ is given, $l$ a prime dividing $p^k-1$, and $f \in L_n$ with two roots $r_1,r_2$ of $f$ so that  $\ord(r_1) \neq \ord(r_2)$ then Algorithm \ref{ALGO:diffords} factors $f$ deterministically in $O(\log(p)n^2k^3)$ operations. 
		\end{thm}

		\begin{proof} 
				If $a,b$ are elements of $\FPE$ with distinct order then by unique factorization there exists a prime $l$ and a positive integer $i$ so that $l^i \mid \ord(a)$ and $l^i \nmid \ord(b)$ or $l^i \nmid \ord(a)$ and $l^i \mid \ord(b)$. Without loss of generality let $l$ be the least prime factor of $p^k-1$ so that $i=\nu_l(\ord(r_1))$ and $i > \nu_l(\ord(r_2))$ for some positive integer $i$ and roots $r_1,r_2$ of $f$. Let $s=\nu_l(p^k-1)$ and $d=(p^k-1)/l^s$ then by Corollary \ref{COR:ORDPOWER}
				\[ l^i \mid \ord \left( r_1^d \right) \textrm{ and } l^i \nmid \ord \left( r_2^d \right). \]
				The components of $\alpha=X^d$ in $R=\FpE[X]/(f)$ are $l^s$th roots of unity. The component corresponding to $r_1$ is a primitive $l^i$th root of unity. The component corresponding to $r_2$ is not a primitive $l^i$th root of unity. Then 
				    \[ r_1^{l^{i-1}} \not= 1 \]
				    \[ r_2^{l^{i-1}} = 1. \]
				In Algorithm \ref{ALGO:diffords} we repeatedly raise $\alpha$ to the power $l$ and let $\beta=\alpha^l$. After doing this $i-1$ times the component corresponding to $r_1$ is not congruent to 1 while the component corresponding to $r_2$ is congruent to 1 and so $\gcd(\beta-1,f)$ is a nontrivial factor of $f$. 
						
				We now consider the number of operations used by the algorithm. We can compute $X^d \pmod f$ using a repeated squaring algorithm in $O(\log(d)(nk)^2)=O(\log(p)(nk)^2)$ operations by Theorem \ref{THM:runTimes}. Again using repeated squaring we can compute $\alpha^l, \alpha^{l^2},\ldots,\alpha^{l^s}$ by first computing $\alpha^l \pmod {\langle f,p \rangle}$ and then finding $\alpha^{l^2},\ldots,\alpha^{l^s}$ by repeatedly multiplying by $\alpha^l$. These two steps take  
				\begin{alignat*}{2}
				    &O(\log(l)(nk)^2+s(nk)^2)=O(\log(l)(nk)^2+\nu_l(p^k-1)(nk)^2) \\
				   =&O(\log(p^k)(nk)^2+\nu_l(p^k-1)(nk)^2)=O(\log(p)n^2k^3)  
			  \end{alignat*}
				$\Fp$-operations. The $\gcd$ of two degree $n$ polynomials over $\FpE$ takes $O((nk)^2)$ operations by Theorem \ref{THM:EASYTIMES} and there are $s$ gcd computations within the while loop. Together the gcds take $O(s(nk)^2)=O(\log(p)n^2k^3)$ operations. 
		\end{proof}
		
		Later in this chapter, in Algorithm \ref{ALGO:INDFAC} we give a more general way to factor polynomials based on the index of the roots. However, this type of factorization generally requires an $m$th nonresidue for some $m$ dividing $p-1$. Such nonresidues cannot be constructed without ERH.
		
		In the algorithms for factoring polynomials over finite fields in this thesis we do not need to directly compute the $\ind(x)$ or $\ind(f)$ for $x$ an element of $\Fq$ or $f$ an element of $\Fq[X]$. This is fortunate as there are no polynomial time algorithms to compute $\ind(x)$. We give Algorithm \ref{ALGO:TWOIND} which computes the index of a finite field element modulo $2^s$. We note that if $x$ is an element of the finite field $\Fq$, $s=\nu_2(q-1)$, $d=2^s$, $e=d^{-1} \pmod {(p-1)/2^s}$ then 
		\[ \ind(x) \equiv de\hspace{2mm} \ind(x) \equiv \ind(x^{de}) \pmod {2^s}. \]
		This congruence is used by the following algorithm.
		
		% ALGO FOR COMPUTING INDEX of an x in Fp
		\begin{singlespace}
    \begin{algorithm}[H]
		\DontPrintSemicolon
		\label{ALGO:TWOIND}
		\caption{$\rm{TWO}\_\rm{IND}$} 	
		\DontPrintSemicolon	
		    Input : $\Fq,\zeta,x$ \;
				\hspace{2mm} $\Fq$ a finite field \;
				\hspace{2mm} $\zeta$ a quadratic nonresidue \;
				\hspace{2mm} $x \in \Fq$ \;
				Output : $\ind(x) \pmod {2^s}$ computed with respect to $\zeta$ with $s$ the largest power of 2 dividing $q-1$ \;
				\;
				% t holds the partial sum of the index
				$s=\nu_2(q-1)$ \;
				$d=2^s$ \;
				$e=d^{-1} \pmod {(p-1)/2^s}$ \;
				$x=x^{de}$ \;
				$t=0$ \;
        \For{$i$ \textup{\textbf{from}} $1$ \textup{\textbf{to}} $s-1$}{
            $a=x^{(q-1)/{2^i}}$ \;
            $b=\zeta^{t \cdot (q-1)/{2^i}}$ \;        
            \If{$ab^{-1} \not= 1$}{
                $t=t+2^{i-1}$ \;
            }
        }
        Return $t$ \;
    \end{algorithm}
		\end{singlespace}
		\vspace{5mm}		
		
		We give an example to illustrate Algorithm \ref{ALGO:TWOIND}. Let $x=1$ and let $p$ be prime so that $\nu_2(p-1)=3$ and $\zeta$ a quadratic nonresidue modulo $p$. Then $\zeta^{2^s}=x$ so we expect $\ind(x) \pmod{2^s}$ to be 0. In the first iteration of the for loop in Algorithm \ref{ALGO:TWOIND} $a=1,b=\zeta^{(p-1)/2}=-1$ (as $\zeta$ is a quadratic nonresidue) and $t$ is not incremented. In the next iteration $a=1,b=\zeta^{(p-1)/4}$ is a primitive fourth root of unity. Again $t$ is not changed. In the last iteration of the loop $a=1,b=\zeta^{(p-1)/8}$ a primitive 8th root of unity. The $t$ returned by the algorithm is zero. 
		
		The problem of computing $\ind(x)$ has been extensively studied due to its relevance in cryptography. Theorem \ref{THM:ind} is given in \cite{hellman}. We note that the number of operations depends on $l$. This is not an issue when $l$ is small but means that applying the theorem for each prime dividing $q-1$ is expensive if $S(q-1)$ is large. 
		
		\begin{thm}
		\label{THM:ind}
		    Let $\Fq$ be a finite field, $g$ be a primitive root in $\FQ$, $l$ be a prime dividing $p^k-1$, and $\nu_l(p^k-1)$. Then there exists an algorithm, of which Algorithm \ref{ALGO:TWOIND} is a special case that computes $\ind(x) \pmod {l^s}$ with respect to $g$ in $O(lk^3 \cdot \nu_l(p^k - 1)\log(p))=O(lk^4 \cdot \log(p)^2)$ operations.
		\end{thm}
		
		Given a finite field $\FpE$ with $p^k-1=l_1^{s_1} \ldots l_j^{s_j}$ we can apply Theorem \ref{THM:ind} for each prime $l$ dividing $p^k-1$. This gives 
		\[ \ind(x) \pmod {l_1^{s_1}}, \ldots, \ind(x) \pmod {l_j^{s_j}}. \] 
		We can then find $\ind(x)$ using the Chinese remainder theorem. The number of operations required depends on the largest prime factor of $p-1$ which we denote $S(p-1)$. The total cost of computing $\ind(x)$ using this algorithm is $O(S(p-1)k^4 \cdot \log(p)^2)$. The algorithm can be modified so that its running time is improved by a factor of $S(p-1)^{1/2}$ using the \emph{baby step-giant step} method. This modification is the best \emph{deterministic} algorithm for computing $\ind(x)$.
		
		The problem of finding roots of the polynomial $X^n-a$ for $a \in \FpE$ is closely related to computation of $\ind(a) \pmod {l_1^{s_1}}, \ldots , \ind(a) \pmod {l_j^{s_j}}$. The following theorem generalizes the result [\citenum{aTonelli}] on computing square roots modulo a prime $p$. 

    % square roots
		\begin{thm} 
		\label{THM:rootz}
				Let $p^k$ be a prime power, $l$ be a prime such that $l$ divides $p^k-1$. Given an $l$th nonresidue in $\FpE$ there is a deterministic algorithm to compute all solutions to $X^l-a$ in $O(lk^3 \cdot \nu_l(p^k - 1)\log(p))=O(lk^4 \cdot \log(p)^2)$ operations. 
		\end{thm}
		
		We note that the number of operations is essentially a result of doing of doing $l \cdot \nu_l(p^k - 1)$ exponentiations over $\FpE$. We give a proof of Theorem \ref{THM:rootz} for the case $l=2$ over a prime field. 
		
    \begin{proof}
		    Let $p$ be a prime. Suppose we need to find a root of the polynomial $f=X^2-a$ for $a \in \Fp$. As $a^{(p-1)/2} \equiv 1 \pmod p$ if and only if $a$ has a square root we may as well assume that a root of $f$ exists. Equivalently, we can say that $a$ is a quadratic residue as $\ind(a) \equiv 0 \pmod 2$. Let $s=\nu_l(p-1)$, $v \equiv 2^{-s} \pmod {(p-1)/2^s}$, $y={(p-1)/2^s}$, and $ z=y^{-1} \pmod {2^s}$. Then $a$ can be written as a product of two elements $\alpha$, $\omega$ in $\Fp$ such that $\alpha$ has odd order and $\omega$ has order not divisible by ${(p-1)/2^s}$. Let
				\begin{alignat*}{2}
				    \alpha &= a^{2^s v} \\
				    \omega &= a^{y z} 
				\end{alignat*}
				then $a=\alpha \omega$. Now we can construct a square root of $a$ by constructing a square root of $\alpha$ and $\omega$ separately. Let $j=2^{-1} \pmod {(p-1)/2^s}$ then $\alpha^j$ is a square root of $\alpha$. 
				
				Suppose we have a quadratic nonresidue $\zeta$ then using Algorithm \ref{ALGO:TWOIND} we can find a positive integer $k$ such that $\zeta^k=\omega$. We have $\ind(a)=\ind(\alpha)+\ind(\omega)$. As $a$ is a quadratic residue $\ind(a) \equiv 0 \pmod 2$. As $\alpha$ has odd order $\ind(\alpha) \equiv 0 \pmod 2^s$ so in particular $\ind(\alpha) \equiv 0 \pmod 2$. Hence $\ind(\alpha) \equiv 0 \pmod 2$ and $\zeta^{k/2}$ is a square root of $\alpha$. 
				
				Multiplying the square roots of $\alpha$ and $\omega$ together we get that $b=\alpha^j\omega^{k/2}$ is a square root of $a$. The other set of all solutions to $X^2-a$ is $\{b,-b \}$.
				
		\end{proof}
		
		We note that although Theorem \ref{THM:rootz} is given for finding roots of $X^l-a$ for prime $l$ it can be extended $X^n-a$ for arbitrary $n$. The idea is to factor $n$ as $n=l_1^{e_1} \cdots l_k^{e_k}$. Then for prime $l$ and positive integer $k$ define $H_{l,k}=\{z \in \Fp, h \in H_{l,k-1} : z^l-h \}$ and $H_{l,0}=\{z \in \Fp : z^l-a \}$. We can recursively compute each of the sets $H_{l,k}$ using Theorem \ref{THM:rootz}. Then the set of all solutions to $X^n-a$ is the direct product of $H_{l_1,e_1},\ldots,H_{l_1,e_1}$. 
								
		The next algorithm factors polynomials over a finite field if $X^{(q-1)/{l^s}} \not\in \Fq \pmod f$ where $l^s$ is the largest power of a prime $l$ dividing $q-1$. In Algorithm \ref{ALGO:INDFAC} $\textrm{MROOT}(x,\zeta,r)$ with $x$ an element of $\FQ$, $\zeta$ an $l$th nonresidue, and $r$ a divisor of $q-1$ is any algorithm that returns an $r$th root of $x$ if it exists. 
				
		% THIS ALGO ONLY WORKS IF f is SQF
		\begin{singlespace}
		\begin{algorithm}[H] 
		\DontPrintSemicolon
		\label{ALGO:INDFAC}
		\caption{IND\_FAC}
		\DontPrintSemicolon
		    Input: $\Fq,l,\zeta,f$ \;
				\hspace{2mm} $\Fq$ a finite field \;
				\hspace{2mm} $l$ a prime dividing $q-1$ \;
				\hspace{2mm} $\zeta$ an $l$th nonresidue in $\Fq$ \;
				\hspace{2mm} $f$ a squarefree polynomial in $L_n$ over $\Fq$ \;
		    Output: A factor of $f$ if a condition is met, otherwise FAIL \;
				\;
				$s=\nu_l(q-1)$ \;
		    $h=X^{(q-1)/{l^s}} \pmod {\langle f,\Fq \rangle}$ \;
				\If{$h \in \Fq$}{
				    return FAIL \;
				}
		    \While{$h \not\in \Fq$}{ 
				    \tcc{The polynomial $t$ is an $r$th root of $h$} 
				    $\beta=h$ \;
			      $h=h^l$ \;
		    }
				\tcc{Construct $\omega$ an $l$th primitive root of unity from $\zeta$} 
				$\omega=\zeta^{(q-1)/l}$ \;
				$z=\rm{MROOT}(h,\zeta, l)$ \;
				\For{$i=0$ \textup{\textbf{to}} $l-1$}{
				    $g=\gcd(\beta-\omega^{i}z,f)$ \;
					  Return $g$ \;
				}
		\end{algorithm}
		\end{singlespace} 
		\vspace{5mm}		
		
		We give an example to illustrate this algorithm. Let $p$ be a prime so that $\nu_2(p-1)=4$ and $z$ be a quadratic nonresidue modulo $p$. Let $a$ and $b$ be distinct elements of $\Fp$ of odd order, and let
		
		\[ f=\left(X-az \right) \left(X-bz \right)\left(X-az^3 \right)\left(X-bz^3 \right)\left(X-az^{13} \right)\left(X-bz^{13} \right) .\]
		
	  We compute the index of the roots with respect to $z$:
		
		\[ \ind(az^i) \equiv \ind(a)+\ind(z^i) \equiv \ind(z^i) \pmod {2^s} \]
		
		\noindent where the last equality holds because $a$ has odd order. Similarly we have $\ind(bz^i)\equiv \ind(z^i) \pmod {2^2}$. Hence $\ind(f) \equiv (1,1,3,3,13,13) \pmod {2^s}$ where $\ind$ is computed with respect to the quadratic nonresidue $z$. In base two these indexes are $I=[i_1,i_2,i_3,i_4,i_5,i_6]=[1,1,11,11,1101,1101]$. In this representation the lowest bit of each element of $I$ is 1. Consider what happens when we apply Algorithm \ref{ALGO:INDFAC} to this polynomial. As all the indexes are equal on this bit, in Algorithm \ref{ALGO:INDFAC} the element $h^{2^3}$ is in $\Fp$. So the while loop in the algorithm terminates after at most 3 iterations. 
		
		As the second lowest bit is different for $i_1$ and $i_3$ the element $h^{2^2}$ is not in $\Fp$ so the while loop is terminated after exactly three iterations. The algorithm recovers the factors $h_1,h_2$ whose roots have the second lowest bit in their base 2 indexes equal to 0 and 1 respectively. These are
		
		\[ 
		    h_1=\left(X-az^3\right)\left(X-bz^3\right)\left(X-az^{13}\right)\left(X-bz^{13}\right) \hspace{13 mm} h_2=\left(X-az\right)\left(X-bz\right). 
		\]
		
		The indexes of $h_1$ in base two are $[11,11,1101,1101]$ so the distinct indexes differ on the second lowest bit. Hence when Algorithm \ref{ALGO:INDFAC} is applied to $h_1$ the while loop is terminated after two iterations. We get the factorization $h_1=g_1g_2$ where
		\[ 
		    g_1=\left(X-az^3\right)\left(X-bz^3\right) \hspace{13 mm} g_2=\left(X-az^{13}\right)\left(X-bz^{13}\right). \hspace{13 mm} 
		\]
		The factorization $f = g_1 g_2 h_2$ is as far as we can go using Algorithm \ref{ALGO:INDFAC} with $l=2$; let $a$ and $b$ be arbitrary roots of distinct elements of the set $\{ g_1,g_2,h_2 \}$ then $\bind(a) \not\equiv \bind(b) \pmod {2^s}.$ 
		
		\begin{thm} 
		\label{THM:vonzurGathen}
		    Let $\FpE$ be a finite field, $f$ a squarefree polynomial in $L_n$, $l$ be a prime such that $p^k-1=ml^s$ where $l$ does not divide $m$, $\zeta$ an $l$th nonresidue, and $X^m \not= 1 \pmod f$. Then Algorithm \ref{ALGO:INDFAC} factors $f$ deterministically in $O(k^4\log(p)^2(n^2+l))$ operations. 
		\end{thm}
		
		\begin{proof}
		    Let $\alpha=X^{(q-1)/{l^s}} \pmod f$ and $v=M(\alpha)$, $r$ be a root of $v$, and $[\ind(r)[l^0],\ldots,\ind(r)[l^{s-1}] ]=[a_0,\ldots,a_{l-1}]$. Then by Lemma \ref{LEM:leftShift}
				\begin{alignat*}{5}
				    &[\ind(r)[l^0],     \ldots&&,     \ind(r)[l^{s-1}] ]           &&= [a_0,&&a_1\ldots ,&&a_{s-1}]   \\
						&[\ind(r^l)[l^0],   \ldots&&,     \ind(r^l)[l^{s-1}] ]         &&= [0,  &&a_0,\ldots,&&a_{s-2}]   \\
						&     \vdotswithin{\ind(r^l)[l^0]}&&                           &&\vdotswithin{=}    &&&&              \\
						&[\ind(r^{l^{s-1}})[l^0],\ldots&&,\ind(r^{l^{s-1}})[l^{s-1}] ] &&= [0,  &&0,\ldots  ,&&a_0 ]. 
				\end{alignat*}
				There is some least positive integer $i$ so that for any pair of roots $r_1,r_2$ we have 
				    \[ [\ind(r_1^{l^{i}})[l^0],\ldots,\ind(r_1^{l^{i}})[l^{s-1}]=[\ind(r_2^{l^{i}})[l^0],\ldots,\ind(r_2^{l^{i}})[l^{s-1}]. \]
				Let $\beta=\alpha^{l^{i-1}}$, and $z \in \Fp$ be an $l$th root of $\beta^l$. Let $b$ be an arbitrary component of $\beta$ then by Lemma \ref{LEM:comRoot} for every $0<k<s-2$ we have $\ind(b)[l^k]=\ind(z)[l^k]$. Let $\omega$ be an $l$th primitive root of unity and $i$ a positive integer then $\ind(\omega^i z)[l^{s-1}]=i \cdot \ind(\omega)[l^{s-1}]+\ind(z)[l^{s-1}]$. We choose $i$ so that $\ind(b)[l^{s-1}]=\ind(\omega^iz)[l^{s-1}]$. Hence as $b$ and $z$ are both $l^s$ roots of unity $\ind(b)=\ind(\omega^iz)$ and $b={\omega^i}z$. So for this $i$ we have $\beta-{\omega^i}z$ is 0 on one component. However, it cannot be zero on every component or $\beta$ would be in $\Fp$. Therefore, $\gcd(\beta-\omega^{i}z,f)$ is a factor of $f$. 
				
				We now consider the number of operations. $h$ can be computed in $\log(p)(n^2k^3)$ by Theorem \ref{THM:runTimes} and $s=\nu_{l}(p^k-1)=O(k\log(p))$ so all the powers of $h$ can be computed in $\log(p)^2(n^2k^4)$ operations. MROOT uses $O(l \cdot \log(p)^2 k^4)$ operations by Theorem \ref{THM:rootz}. Computing each of the polynomials $g$ requires a gcd operation which takes $O((nk)^2)$ operations by Theorem \ref{THM:EASYTIMES} so $O(l(nk)^2)$ operations are needed to compute them all. Hence Algorithm \ref{ALGO:INDFAC} uses $O(\log(p)^2 k^4(n^2+l))$ operations.
		\end{proof}
		
	  %We note that Lemma \ref{LEM:FlatSQF} does not hold in general if $f$ is not squarefree. For example, let $p=5$ and $f=(X-1)^2$. Then $X^{(p-1)/2} \equiv 2X+4 \pmod f$ but $\gcd(2X.
		
		In the algorithms in Chapter \ref{CH:rFPFF} and Chapter \ref{CH:uncond} we are often given a squarefree polynomial $f$ that is a product of linear factors over a finite field to factor. We construct a polynomial $g$ so that $g=(X-r_1)^{e_1} \cdots (X-r_n)^{e_n}$ where $r_1,\ldots,r_n$ are the roots of $f$. It is sometimes possible to factor $g$ which in turn allows a factorization of $f$.
			
		\begin{mydef}
		\label{DEF:flat}
		    Given a squarefree polynomial $f \in L_n$ over a finite field $\Fq$ a polynomial $g$ is \emph{flat} if $f=\gcd(f,g)$ and every root of $g$ has the same multiplicity.
		\end{mydef}
		
		\begin{singlespace}
		\begin{algorithm}[H] 
		\DontPrintSemicolon
		\label{ALGO:NONFLAT}
		\caption{NON\_FLAT}
		    Input: $\FPE,f,g$ \;
				\hspace{2mm} $\FPE$ a finite field \;
				\hspace{2mm} $f=\prod_{i=1}^k{f_i}$ with $f_i$ irreducible polynomials \;
				\hspace{2mm} $g=\prod_{i=1}^k{f_i^{j_i}}$ \;
				Output : 1 if $f$ is not flat, otherwise a nontrivial factor of $f$ \;
				\;
		    $h=g$ \;
		    \While{$f \mid \gcd(h,f)$}{ 
			      $h=h/f$ \;
		    }
		    Return $\gcd(h,f)$
		\end{algorithm}
		\end{singlespace}
	  \vspace{5mm}		
		
		For example let $f=(X-r_1)(X-r_2)$ and $g=(X-r_1)(X-r_2)^2$ over some prime field $\Fp$. As $f$ is not flat we can factor it using Algorithm \ref{ALGO:NONFLAT}. The polynomial $h$ is initialized to $g$ and $f$ divides $h$ so $h=h/f=(X-r_2)$. Then $f$ does not divide this new $h$ so $(X-r_2)$ is returned. 
		
		\begin{lem}
		\label{THM:NONFLATTime}
		    Let $\Fq$ be a finite field and $f,g \in L_n$ over $\Fq$ so that $g$ is not flat with respect to $f$. Then Algorithm \ref{ALGO:NONFLAT} returns a factor of $f$ in $O( m(n+m)^2 k^2)$ operations. 
		\end{lem}
		
		\begin{proof}
		    Let $g=\gcd(g,f)= {a_1}^{e_1} \cdots {a_k}^{e_k} $ with each $a_i$ a factor of $f$ of degree one and $e_1 \leq e_2 \leq \cdots \leq e_k$. Then $f$ divides $\gcd(g,f)$. In the algorithm $h$ is initialized as $g={a_1}^{e_1} \cdots {a_k}^{e_k}$. Now we consider the factorization of $h$ as $h={a_1}^{e_1} \cdots {a_k}^{e_k}$ after each iteration of the while loop. Each division of $h$ by $f$ in the while loop reduces each of the $e_i$ by one. This is repeated until $e_1=0$. We need to show that if $g$ is not flat with respect to $f$ at this point $\gcd(h,f)$ is a nontrivial factor of $f$. Note that $\gcd(h,f)$ is a squarefree divisor of $f$. As $e_1=0$ we have $f$ does not divide $\gcd(h,f)$. As $g$ is not flat there are at least two distinct elements in the set $\{ e_1,\ldots,e_k \}$ so $\gcd(h,f)$ is not equal to $f$. Hence $\gcd(h,f)$ is a nontrivial factor of $f$. 
				
				We now consider the number of operations. Let $m=\deg(g)$. As the $e_i$ are reduced by one after each iteration the loop iterates at most $m$ times in total. Each iteration uses one division and one $\gcd$ both of which take $O( (n+m)^2 k^2)$ operations.
		\end{proof} 
		
    \subsection{Graph Theory Background}
	  \label{SEC:GT}
						
			  In this section we give some definitions and lemmas related to graph theory. A graph is a pair $(V,E)$ where $V$ is a nonempty set and $E$ is a set of unordered pairs of elements of $V$. In general the vertices can be arbitrary, but in this thesis they will always be indeterminants or positive integers less than $p$ for some given prime $p$. These are the \emph{vertices} and \emph{edges} of a graph, respectively. Two vertices $a$ and $b$ are called \emph{adjacent} if $(a,b) \in E$. If a pair of vertices is adjacent then the pair are referred to as neighbors.  A \emph{cycle} of a graph $G$ is a sequence of vertices $v_1,\ldots, v_n$ such that no pair of distinct vertices are equal except the first and the last. An \emph{edge cycle} on a graph $G$ is a sequence of edges such that for any vertex $v$ in $G$, $v$ is in two of the edges of the cycle.  

        The number of edges adjacent to a vertex $v$ is the \emph{degree} of $v$. A graph is \emph{regular} if every vertex has the same degree. A directed graph (digraph) is a pair $(V,E)$ so that $V$ is nonempty and $E$ is a set of ordered pairs of elements of $V$. The sets $V$ and $E$ are the vertices and the edges (also called arcs) of $G$. The indegree of a vertex $v$ is the number of elements of $E$ that have $v$ as their second element, and the outdegree is the number of elements of $E$ that have $v$ as their first element. A digraph is \emph{regular} if the indegree and outdegree of every vertex are equal to a positive integer $k$. A \emph{circuit} of a digraph $G$ is a sequence of vertices $v_1,\ldots, v_n$.
				
				This rest of this section discusses a type of digraph called tournaments. These graphs are only referenced to in the chapter on results on FPFF that are conditional on ERH. A \emph{tournament} is a directed graph in which every pair of vertices is joined by exactly one arc. A vertex $a$ \emph{dominates} a vertex $b$ if there is an arc from $a$ to $b$. The \emph{score} $s(v)$ of a vertex $v$ is the number of vertices dominated by it. A tournament on $n$ vertices is called an $n$-tournament. The \emph{converse} $T'$ of a tournament $T$ has the same vertex set as $T$ but all the arcs are reversed. Figure \ref{FIG:tourn1} provides an example of a 5-tournament

        \begin{center}
        \begin{figure} \input{C:/ttex/regTournEx.txt} \caption{A tournament on 5 vertices.} \label{FIG:tourn1} \end{figure}
        \end{center}

        The number of tournaments is $2^{\binom{n}{2}}$. The number of regular tournaments is determined in [\citenum{McKay90}]. See [\citenum{tourns}] for a survey of results on tournaments. 

        Let $G$ be a graph or digraph with vertices $\{Y_1,\ldots,Y_n \}$ for some positive integer $n$. If $\Fp$ is a prime field containing all the $Y_i$ then the \emph{vertex polynomial} is $\prod_{i=1}^n{(X-Y_i)}$. From now on whenever we give an algebraic expression involving a set of vertices of some graph $Y_1,\ldots, Y_n$ it is implicit that $Y_i$ are elements of a prime field. 

        % ARC POLYNOMIAL

				\begin{mydef}
				\label{DEF:edgepoly}
				    Let $G$ be an undirected graph with vertices $\{Y_1,\ldots,Y_n \}$ and $\ast$ be a commutative binary operation. The \emph{edge polynomial} of $G$ with respect to $\ast$ is 
            \[
                \prod_{(Y_i,Y_j) \in E}{(X-Y_i \ast Y_j)}.
            \]
        \end{mydef}
        
				\noindent For example, the edge polynomial of the complete undirected graph on $n$ vertices is \[ \prod_{1 \leq i<j<n}{(X-Y_i \ast Y_j)}. \]
        % n=4 is enough to illustrate with perfect clarity
        In particular, the arc polynomial corresponding to the complete undirected graph on 4 vertices with respect to the operation of ordinary addition is $(Y-(r_1+r_2))(Y-(r_1+r_3))(Y-(r_1+r_4))(Y-(r_2+r_3))(Y-(r_2+r_4))(Y-(r_3+r_4))$.

        Any graph on $n$ vertices can be given as a list where the $i$th entry is all the edges which have the $i$th vertex as an endpoint. The edge polynomial may be thought of as an encoding of the adjacency list representation of a graph. We now define an analogous polynomial for digraphs. 
				
				\begin{mydef}
				\label{DEF:arcpoly}
				    Let $G$ be a digraph with vertices $\{Y_1,\ldots,Y_n \}$ and $\circ$ be a noncommutative binary operation. The \emph{arc polynomial} of $G$ with respect to $\ast$ is 
            \[
                \prod_{(Y_i,Y_j) \in E}{(X-Y_i \ast Y_j)}.
            \]
        \end{mydef} 

        Let $G$ be a tournament with vertices $\{Y_1,\ldots,Y_n \}$ for some positive integer $n$. The \emph{score polynomial} of a tournament is $ \prod_{i=1}^n{(X-Y_i)}^{s(Y_i)} $.  
%
%
\newpage
\chapter{Related Work on FPFF}
\label{CH:rFPFF}
%
%			
    \subsection{Deterministic Algorithms}
		\label{SEC:DETALG}
        In this section we summarize the results in the literature on FPFF that are probabilistic, deterministic, and deterministic under certain conjectures. 
		
		    Probabilistic factorization algorithms were given in [\citenum{zassenhaus1969hensel}] and [\citenum{berlekamp1970factoring}] that use a number of operations polynomial in $\log(q)$ and $\deg(f)$. A more efficient algorithm was given by [\citenum{cantor1981new}]. These probabilistic algorithms are of Las Vegas type, if a solution is produced then it is correct. The asymptotically fastest algorithm for factoring polynomials is given in [\citenum{KedlayaUmans}].
		
		    In the unconditional case there has not been much progress on FPFF. No unconditional and deterministic algorithm for factoring polynomials over $\Fp$ is known that runs in subexponential time in either the degree of the polynomial or $\log(p)$. The oldest general result is a result of Berlekamp [\citenum{berle1967}],[\citenum{berlekamp1970factoring}].
				
				\begin{thm}
				\label{THM:berleFac}
				    Let $\Fq[X]$ be a finite field, and $f$ be a polynomial of degree $n$ over $\Fq$. There exists an algorithm that factors $f$ deterministically in $O((n + q) n^2)$ operations.
				\end{thm}
				
				We note that in the literature the term ``Berlekamp's algorithm'' is used to refer to both the probabilistic and deterministic algorithm for FPFF given in [\citenum{berlekamp1970factoring}]. The following theorem is given in [\citenum{shoup1991fast}].
				\begin{thm}
				\label{THM:DETERMFAC}
				    Let $\mathbb{F}_{p^k}$ be a finite field and $f$ a degree $n$ polynomial in $\mathbb{F}_{p^k}[X]$. Then $f$ can be factored deterministically in 
						     \[ \log(p)\tilde{O}((nk)^2) + p^{1 / 2} \log(p) \tilde{O}((nk)^{3/2}) \] 
						operations. 
				\end{thm}
				
				An algorithm for factoring almost all polynomials deterministically is given in [\citenum{shoup1990deterministic}] and this result is extended in [\citenum{lange2000factoring}]. 

		    Many results on deterministic FPFF pertain to finding roots of polynomials in $\Fq[X]$ of the form $X^n - z$ with $z$ a finite field element. In this case a root of the polynomial is called an $n$th root of $z$. Deterministic algorithms for computing $n$th roots exist which run in polynomial time in special cases. In [\citenum{schoof1985elliptic}] an algorithm for computing a square root of $x$ (if one exists) in $\Fp$ that uses $O((x^{1/2 + \epsilon} \log(p) )^9)$ operations is given as an application of an algorithm for counting points on elliptic curves. Using related ideas, [\citenum{pila1990frobenius}] shows that for any odd prime $l$ and prime $p$ such that $p \equiv 1 \pmod{l}$ an $l$th primitive root of unity in $\Fp$ can be computed in $\poly(\log(p), l)$. A deterministic algorithm to compute square roots in finite fields that runs in polynomial time for some special finite fields is given in [\citenum{sze2011taking}].

	      Many of the results on factoring polynomials over finite fields depend on the Riemann Hypothesis (RH) or generalizations of it. Before providing these results we give the statement of RH and two of the commonly used generalizations. 		
		%
		%
		\subsection{Riemann Hypothesis}
		%
		%
	
				Most of the results on factoring polynomials over finite fields assume either the Riemann Hypothesis or a generalization of it. The two generalizations that are commonly used are the Extended Riemann Hypothesis (ERH) and the Generalized Riemann Hypothesis (GRH). We give the statement of these conjectures in their simplest form. The definitions and theorems in this section follow Chapter 8 of [\citenum{bach1996algorithmic}]. Let
				\[li(x)=\int_{2}^x{\frac {dt}{\log(t)}}. \]

				\noindent and let $\pi(x)$ be the number of primes less than or equal to $x$. First we state the ordinary Riemann Hypothesis.

				Riemann Hypothesis: Let $x$ be a positive integer. For any $\epsilon>0$ 
				\[\pi(x) = li(x)+O(x^{\frac {1}{2}+\epsilon}). \]

				It was proved by Dirichlet that if $\gcd(a,n)=1$ then there are infinitely many primes congruent to $a$ modulo $n$. (These are called primes in an arithmetic progression). Let $\pi(x,n,a)$ be the number of primes $p$ less than or equal to $x$ such that $p \equiv a \pmod n$. The Extended Riemann Hypothesis (ERH) is a generalization of the Riemann hypothesis which can be stated in terms of primes in arithmetic progressions. Recall that $\phi(n)$ is the Euler totient function. 
        Extended Riemann Hypothesis: Let $x,n,a$ be positive integers and $a$ and $n$ be relatively prime, then for any $\epsilon>0$ 
				\[\pi(x,n,a) = \frac {li(x)}{\phi(n)}+O(x^{\frac {1}{2}+\epsilon}). \]

				Any finite extension of the rationals of finite degree is called an \emph{algebraic number field}. The generalization of the Riemann Hypothesis to algebraic number fields is called the Generalized Riemann Hypothesis. 

				Algebraic number fields are often represented in the form $\mathbb{Q}[X]/(f)$ where $f$ is an irreducible polynomial in $\mathbb{Z}[X]$. The \emph{degree} of an algebraic number field is its dimension as a vector space over $\mathbb{Q}$. If $k$ is an algebraic number field of degree $n$ there are $n$ field homomorphisms from $k$ into $\mathbb{C}$. These are given by the factorization of $f$ and are called \emph{embeddings}. 

				\begin{mydef}
				\label{DEF:NORM}
				    Let $k$ be an algebraic number field of degree $n$ and $\alpha_1,\ldots, \alpha_n$ be its embeddings. The norm of $x \in k$ is defined 
				    \[N(x)=\prod_{i=1}^n{\alpha_i(x)}.\]
				\end{mydef}

				\begin{thm}
				\label{THM:minpol}
				    If $k$ is an algebraic number field of degree $n$ and $x \in k$, then there is a unique monic polynomial $f \in \mathbb{Q}[X]$ of degree less than or equal to $n$ such that $f(x)=0$ and for any polynomial $g \in \mathbb{Q}[X]$ if $g(x)=0$ then $f \mid g$. Then $f$ is called the \emph{minimal polynomial} of $x$. 
				\end{thm}
				
				Let $k$ be an algebraic number field and $R$ be the subset of $k$ such that the minimal polynomial of every element in $R$ is in $\mathbb{Z}$. Then $R$ forms a subring and is called the ring of \emph{algebraic integers} of $k$.
 
				A nonzero ideal $A$ of the ring of integers $R$ of an algebraic number field is a \emph{prime ideal} if $A/P$ is an integral domain. An analogue of the prime number theorem is known for prime ideals. For any algebraic number field the number of prime ideals is infinite. 

				For an algebraic number field $k$ let $\pi_k(x)$ be the number of prime ideals with norm less than or equal to $x$. 

				Generalized Riemann Hypothesis: Let $k$ be an algebraic number field, then for any $\epsilon>0$

				\[\pi_k(x) = li(x)+O(x^{\frac {1}{2}+\epsilon})\]
   
		%
		%
		\subsection{Results Depending on RH, ERH, GRH}
		%
		%				
		    Many algorithms for polynomial factorization over $\Fp$ require the construction of nonresidues. For example, the first step of the algorithm of Theorem \ref{THM:rootz} for computing square roots in $\Fp$ (i.e. finding a root of the polynomial $X^2-a$ for $a \in \Fp$) is finding a quadratic nonresidue. It is easy to construct a nonresidue probabilistically. Finding nonresidues deterministically is more challenging. In prime fields testing $1, 2, \ldots$ until an $m$th nonresidue is found is the best known approach known. Typically, one way to bound the size of the set required is by bounding a character sum. We define the \emph{Jacobi symbol} as $\chi$. We let $\chi(x)=1$ if $x$ is a quadratic residue modulo $p$ and $\chi(x)=-1$ if $x$ is a quadratic nonresidue modulo $p$. Suppose we can find $M$ so that
		    \[\sum_{x=1}^{m}{\chi(x)}<M\]
		    \noindent then this forces the existence of a quadratic nonresidue modulo $p$ less than $M$. 

		    For many character sums that arise in polynomial factorization algorithms there is a significant gulf between what can be proved unconditionally, and what can be proved on conditions such as the Riemann Hypothesis, or at least motivated heuristically. For example, the best bound on the sum above is $O \left( p^{1/{4\sqrt{e}}+\epsilon } \right)$ for any $\epsilon>0$ \cite{burgess}. Under ERH the sum is bounded by $O(\log(p)^2)$. 
		    \begin{thm} 
		    \label{THM:ERHNonres}
		        Let $m$ be a divisor of $p-1$. The least $m$th nonresidue modulo $p$ is $O(\log(p)^2)$ under ERH.
		    \end{thm}

		    Theorem \ref{THM:ERHNonres} was given in [\citenum{ankeny1952least}] in the case $m=2$. A proof of the full theorem is given in [\citenum{bach1996algorithmic}] Chapter 8. 

		    \begin{thm} 
		    \label{THM:Huang}
		        The following have algorithms that use a polynomial number of operations in $q$ and $\log(p)$ under GRH. 
						\begin{itemize}
		        \item Given primes $q, p$ factor $\Phi_q \pmod p$ 
		        \item Given primes $q, p$ construct a $q$th nonresidue in $\Fp[X]/(h)$ where $h$ is an irreducible factor of $\Phi_q \pmod p$. 
						\end{itemize}
		    \end{thm}

		    Using this algorithm $m$th nonresidues in $\Fq[X]$ can be constructed in $\poly(m, \log(q))$ field operations.

		    The problems of finding $l$th nonresidues and taking $l$th roots are closely related. Given an $l$th nonresidue, $l$th roots can found deterministically. In the other direction, if a primitive $l$th root of unity $\omega_l$ in $\Fq$ is known, an algorithm for taking $l$th roots could be used to repeatedly take roots of $\omega_l$ until an $l$th nonresidue is found. In the case $l = 2$, -1 is a primitive 2th root of unity so the problem of computing quadratic nonresidue reduces to the problem of computing square roots.
				
				The next theorem was proved in [\citenum{ronyai1988factoring}]. We will also prove this result in Chapter \ref{CH:ERH}. Recall that we defined $L_n=\left\{ f : f=\prod_{i=1}^n{(X-a_i)} , a_i \in \FQ \right\}.$
		
	      \begin{thm} 
				\label{THM:Ronyai}
			      Let $f$ be a squarefree polynomial in $L_n$ over $\Fp$. Let $r$ be a prime divisor of $n$ and suppose that the $r$th cyclotomic field $F$ over $\Fp$ and an $r$th nonresidue in $F$ are given. Then we can find a nontrivial factor of $f$ in $\poly(\log(p), n^r)$ time under GRH.
		    \end{thm}
				
				The best result on factoring general polynomials under GRH is the following result, given in [\citenum{evdokimov1994factorization}].
				
				\begin{thm} 
				\label{THM:Evo}
			      Let $\FpE$ be a finite field and $f$ be a degree $n$ polynomial over $\FpE$. Then $f$ can be factored deterministically in $\poly(\log(p),n^{\log(n)})$ operations under GRH. 
		    \end{thm}
				
		    The following theorem is given in [\citenum{evdokimov1989factoring}]. It gives a condition for factorization on the Galois group.

		    \begin{thm}
				\label{THM:GALOIS}
			      Let $f$ be a squarefree polynomial in $L_n$ over $\Fp$ with solvable Galois group over $\mathbb{Q}$. Then $f$ can be completely factored into irreducible factors in $\poly(\log(p), n)$ operations under GRH. 
		    \end{thm}
		
		    In [\citenum{gao}] an algorithm for factoring a class of polynomials which are called \emph{super-square balanced} in polynomial time under GRH is given. A conjecture is given under which the algorithm would factor any polynomial in deterministic polynomial time under GRH. In [\citenum{Saha}] this approach is generalized and in [\citenum{ChengH00}] an algorithm related to [\citenum{gao}] is given. These approaches start from the following idea. Given a polynomial $f=\prod_{i=1}^n{(X-r_i)}$ then we can define a corresponding directed graph $G$ with vertices labeled $\{r_1,\ldots,r_n \}$ such that there is an arc $r_ir_j$ for $i \not=j$ if $\chi(r_i-r_j)=1$ and an arc $r_jr_i$ otherwise. 
				% Check Huang's paper 
				The score $s(v)$ of a vertex $v$ is the number of arcs leaving it. Let $V(G)$ be the set of vertices of of $G$. It is possible to construct the polynomial 
		    \[ h = \prod_{v \in V(G)}^n{(X-v)}^{s(v)}. \]
		
		    Recall that we call a polynomial flat if the multiplicity of every factor is the same. If there is a pair of vertices with different scores then $h$ is not flat and so $f$ can be factored by Algorithm \ref{ALGO:NONFLAT}. The papers [\citenum{gao}] and [\citenum{ChengH00}] develop different approaches for dealing with the case that $s(v)$ is the same for every vertex. 
				The next two theorems make use of an algebraic-combinatorial generalization of [\citenum{ChengH00}]. The following theorem is given in [\citenum{ivanyos2009schemes}].

		    \begin{thm}
				\label{THM:PrimeDeg}
			      If $n>2$ is prime, $r$ the largest prime factor of $(n-1)$ and $f$ is a degree $n$ polynomial over $\Fp$ then a $f$ can be factored deterministically in $\poly(\log( p), n^r)$ operations under GRH.
		    \end{thm}
				
				The next theorem is given in [\citenum{arora2012deterministic}].
				
		    \begin{thm} 
				\label{THM:MorePrime}
			    Let $f$ be a polynomial of prime degree $n$ over $\Fq$. Assume that $n-1$ has a $r$-smooth divisor $s$, with $s \geq \sqrt{n/l}+1$ and $l \in \mathbb{N}>0$. Under GRH we can find a nontrivial factor of $f$ deterministically in $\poly(\log(q), n^{r+\log(l)})$ operations.
		    \end{thm}
		
		    %Gao's conjecture has no obvious motivation and although the conjecture can easily be tested Gao does not say to what extent he has tested it. \citenum{saha} generalizes the approach of \citenum{gao}.
				
				The following theorem was proved in [\citenum{von1987factoring}]. It shows that for special finite fields any polynomial can be factored. The main tool used in the proof is Algorithm \ref{ALGO:INDFAC}.
		    \begin{thm} 
				\label{THM:SmoothFac}
		        Every $f \in \Fp[X]$ can be factored deterministically in $\poly(S(p-1),\log(p),n)$ operations under ERH.
		    \end{thm}
		
		    \begin{proof}
		        We can factor $p-1=l_1^{e_1}\cdots l_k^{e_k}$ in the time bound by trial division. By Theorem \ref{THM:rootFinding} we may as well assume that $f$ is a squarefree polynomial in $L_n$ over $\Fp$ and so every element in $\ind(f) \equiv [\ind(r_1),\ldots, \ind(r_n)] \pmod {p-1}$ is distinct. We want to show that there exists $l$ dividing $p-1$ so that at least two entries in $\ind(f) \equiv [\ind(r_1),\ldots,\ind(r_n)] \pmod {l^s}$ are distinct. Suppose no such $l$ exists, then in particular we have $\ind(r_1) \equiv \ind(r_2) \pmod {l^s}$ for every $l$ dividing $p-1$. Hence by the Chinese remainder theorem we have $\ind(r_1) \equiv \ind(r_2) \pmod {p-1}$. However, since $\ind(r_1) < p-1$ and $\ind(r_2) < p-1$ this implies $r_1 = r_2$. As $f$ is squarefree $r_1=r_2$ is a contradiction and so such an $l$ must exist. 
						
						Our goal now is to factor the polynomial $f$ using Theorem \ref{THM:vonzurGathen} where $l$ is the prime given as input to the algorithm. In order to apply Theorem \ref{THM:vonzurGathen} we need an $l$th nonresidue for each $l$ dividing $p-1$. By Algorithm \ref{ALGO:INDFAC} under ERH we can construct each $l$th nonresidue in $O(\log(p)^2)$ operations and so we can construct the set of nonresidues in $O(\log(p)^3)$. Then we apply Algorithm \ref{ALGO:INDFAC} to get a factor of $f$. By Theorem \ref{THM:vonzurGathen} the factor is constructed in $\poly(S(p-1),\log(p),n)$ operations.
		    \end{proof}
				In Chapter \ref{SEC:CompOps} we remove the condition of ERH when $\gcd(n,\phi(p-1))=1$.
	
%
%
\newpage
\chapter{Factoring Polynomials Unconditionally}
\label{CH:uncond}
%
%
    % this ends the material added on June 19
    Section \ref{SEC:CompOps} gives background information on some operations that are useful for polynomial factorization. We use these composed operations in both Chapter \ref{CH:uncond} and Chapter \ref{CH:ERH}. 
		
	  Through the results of Chapter \ref{CH:Background} we know that given a nontrivial factor of a polynomial $f$ of degree $n$ over a finite field $\FPE$, in order to construct a nontrivial factor of $f$ it suffices to find a root of a polynomial $h$ in the following set
		\[ L_m=\{ f=\prod_{i=1}^n{(X-a_i)} : f\in \Fp[X], a_i \in \Fp \} \]
		\noindent with $m \leq n$ and which is squarefree. Given a root of $h$ we can work backwards to construct a factor of $f$. 
		
		In Section \ref{SEC:CoDeg} we give the main contribution of this chapter Theorem \ref{THM:CoDeg}. Earlier we defined $S(x)$ to be the largest prime factor of $x$. Recall Theorem \ref{THM:SmoothFac} which showed that any polynomial in $L_n$ over $\Fp$ can be factored deterministically in $\poly(S(p-1),\log(p),n)$ operations under ERH. For polynomials with degree coprime to $\phi(p-1)$ Theorem \ref{THM:CoDeg} removes the requirement of ERH. In Section \ref{SEC:bounded} we give a new result in Theorem \ref{THM:boundedDeg} which regards polynomials of bounded degree. We show that bounded degree polynomials can be factored deterministically in $O\left( p^{1/4+o(1)} \right)$ operations. 
		
    %
		%
    \subsection{Composed Operations}
		\label{SEC:CompOps}
		%
		%
		
    A natural starting point for trying to construct a deterministic polynomial time factorization algorithm is to extend a deterministic algorithm $\mathcal{A}$ that takes $f \in \Fp[X]$ as input and outputs a nontrivial factorization for some $f \in \Fp[X]$ when a nontrivial factorization of $f$ does exist, by doing some algebraic manipulation of $f$ to produce a new polynomial $g$, then applying $\mathcal{A}$ to $g$ to get a factor $h$, and then doing another manipulation on $h$ to produce a factor of $f$. 
		
		For example, $\gcd(f,X^{(p-1)/2}-1)$ may produce a factor of $f$. If it does not, then let $f_a=f(X+a)$ for random $a$ in $\Fp$. If the $\gcd$ gives a factor $h$ of $f_a$ then $h(X-a)$ is a factor of $f$. This was first observed by Legendre in [\citenum{Legy}]. A related deterministic factorization algorithm was given by Shoup in [\citenum{shoup1990deterministic}]. 
		
		This idea can be be formalized in the following way. Let $(\mcA,\mcS,\mcT)$ be 3 deterministic polynomial time algorithms so that $\mcA$ takes $\Fp$ polynomials as input and returns either nothing or a factor of the input polynomial, $\mcS$ and $\mcT$ take pairs of $\Fp$ polynomials as input and output $\Fp$ polynomials and if $s=\mcA \circ \mcS(f,h)$ is a nontrivial factor of $\mcS(f,h)$ then $\mcT(f,s)$ is a nontrivial factor of $f$. 
		
		% The composed product was defined in Selmer but not the sum.
		We now introduce five operations on polynomials. These operations are called the \emph{composed power}, \emph{composed sum}, \emph{composed difference}, \emph{composed product}, and \emph{composed quotient}, respectively. Let $f$ and $g$ be polynomials over $\Fq$ with factorizations $f=\prod_{\alpha}{(X-\alpha)}$ and $g=\prod_{\beta}{(X-\beta)}$ in an algebraic closure of $\Fq$. Then
		
		% POW
		\[ f^{(k)} = \prod_{\alpha}({X-\alpha^k}), \]
		
		% SUM DEF / QUO DEF
		\[ f \oplus g = \prod_{\alpha}{\prod_{\beta}({X-(\alpha+\beta)})}, 
	      \hspace{13 mm} 
		    f \ominus g = \prod_{\alpha}{\prod_{\beta}({X-(\alpha-\beta}))}, \]
	
    % PROD DEF / QUO DEF
		\[ f \otimes g = \prod_{\alpha}{\prod_{\beta}({X-\alpha\beta})}, 
	      \hspace{13 mm} 
		    f \oslash g = \prod_{\alpha}{\prod_{\beta}{(X-\frac{\alpha}{\beta})}}. \]
				
		For example, let $f=\Phi_8(X)=X^4+1=(X-\omega)(X-\omega^3)(X-\omega^5)(X-\omega^7)$ where $\omega$ is an 8th root of unity. Then 
		\[ f \oslash f=\left( \left(X-1 \right)\left(X-\omega^2\right)\left(X-\omega^4\right)\left(X-\omega^6\right) \right)^4=(X-1)^4(X+1)^4(X^2+1)^4. \]
				
		%CITE: Flajolet, Bostan, Schost and Salvy%		
	  Computing the composed product efficiently was investigated in [\citenum{Brawley99computingcomposed}] and  [\citenum{schostSpecialResultants}]. Composed products are connected to the minimal polynomials of sums and products of algebraic numbers [\citenum{loos}]. Composed products are also useful for explicit constructions of factors of cyclotomic polynomials [\citenum{cycFac}]. Other references for composed operations can be found in [\citenum{MullenPanario}]. The theorems in this section are given in these papers. 		
			
		The next two theorems deal with the case where the two polynomials in the composed operation are equal. 
		
		\begin{thm}
		\label{THM:facrules}
		    Let $f \in L_n$ such that there exists a polynomial $g \in \Fp[X]$ with $\deg(g)>1$ and $g \mid f$. Let $\diamond$ denote one of the four operations $\oplus,\ominus,\otimes,\oslash$. Then $(g \diamond g) \mid (f \diamond f).$  
		\end{thm}
		
		\begin{thm}
		\label{THM:SumFactor}
		    Let $f=\prod_{i=1}^n{(X-\alpha_i)}$ be a degree $n$ polynomial over an algebraic closure of $\Fq$ then $f \oplus f$, $f \ominus f$, $f \otimes f$,$f \oslash f$ have degree $n^2$ and can be written
				\begin{alignat*}{2}
		    f \oplus  f               &= \prod_{i=1}^n{\left(X-2\alpha_i\right)}\prod_{i<j}{\left(X-(\alpha_i+\alpha_j)\right)}^2    \\ 
				X^{-n}( f \ominus f )     &= \prod_{i<j}{\left(X^2-(\alpha_i-\alpha_j)^2 \right)}                              \\	
				f \otimes f               &= \prod_{i=1}^n{\left(X-{\alpha_i}^2 \right)}\prod_{i<j}{\left(X-(\alpha_i\alpha_j) \right)}^2  \\
				(X-1)^{-n}( f \oslash f ) &= \prod_{i<j}{\left( X^2-X(\alpha_i + \alpha_j^{-1})+1 \right)}         
				\end{alignat*}
		\end{thm}
		
		We now prove two of these statements.
		
		\begin{proof}
		   Let $A=\{\alpha_1,\ldots,\alpha_n \}$. We have $f \oplus f$ satisfies
		    \[ f \oplus g = \prod_{\alpha \in A}{\prod_{\beta \in A}({X-(\alpha+\beta)})} 
						= \prod_{\alpha \in A}{(X-2\alpha)} \prod_{\alpha_1 \in A, \alpha_2 \in A, \alpha_1 \not= \alpha_2}{(X-(\alpha_1+\alpha_2))}. \]
						
				In the product $\prod_{\alpha_1 \not= \alpha_2}{(X-(\alpha_1+\alpha_2))}$ each term $X-(\alpha_1+\alpha_2)$ appears twice so 
				
				\[ f \oplus f =\prod_{i=1}^n{(X-2\alpha)}\prod_{i<j}{(X-(\alpha_i+\alpha_j))}^2. \] 
				
				We have $f \ominus g$ satisfies 
				
			  \[f \ominus f = \prod_{\alpha}{\prod_{\beta}({X-(\alpha-\beta}))}. \]
						
				For each term $r_1= X-(\alpha_1-\alpha_2)$ there is a corresponding term $r_2=X-(\alpha_2-\alpha_1)$ and so $r_1r_2=X^2-(\alpha_1-\alpha_2)^2$ is a factor so 			
				\[ f \ominus f = X^n\prod_{i<j}{(X^2-(\alpha_i-\alpha_j)^2)} . 	\]		
				
				The other statements are proved in a similar way.
		\end{proof}
		
		\begin{thm}
		\label{THM:niceForm}
		    Let $f$ be a squarefree degree $n$ polynomial with roots $A$ in an algebraic closure of $\Fq$ then $f \oplus f$, $f \ominus f$, $f \otimes f$,$f \oslash f$ have degree $n^2$ and can be written			
				\begin{alignat*}{2}				
				f \oplus  f &=  \prod_{\alpha \in A}{f(X-\alpha)},       \\
				f \ominus f &=  \prod_{\alpha \in A}{f(X+\alpha)},       \\
				f \otimes f &=  f(0)^n\prod_{\alpha \in A}{f(X\alpha^{-1})},   \\
				f \oslash f &=  f(0)^{-n}\prod_{\alpha \in A}{f(X\alpha)}.        
				\end{alignat*}
		\end{thm}
		
		\begin{proof}
		For the first equality we have 		
				\[ f \oplus f = \prod_{\alpha \in A}{ \prod_{\beta \in A}{(X-(\alpha+\beta)) }} = \prod_{\alpha \in A}{ \prod_{\beta \in A}{((X-\alpha)-\beta)} } = \prod_{\alpha \in A}{f(X-\alpha)} . \]
		The other equalities are proved similarly. 
		\end{proof}		
		For example, if $f=(X-r_1)(X-r_2)$ then $f(0)=r_1r_2$, $f \otimes f = (X-r_1^2)(X-r_2^2)(X-r_1r_2)^2 = r_1r_2(X/r_1-r_1)(X/r_1-r_2)(X/r_2-r_2)(X/r_2-r_1)=f(0)f(X/r_1)f(X/r_2)$
		
		Let $\Fq$ be a finite field, $f$ be a squarefree polynomial in $L_n$ with roots $r_1,\ldots,r_n$, $R=\Fq[X]/(f)$, and $\alpha \in R$. The element $\alpha$ has a tuple of components $(\alpha_1,\ldots,\alpha_n)$ with $\alpha_i=\alpha(r_i)$. Recall that the minimal polynomial of $\alpha$ is defined 
		\[ M_{X}(\alpha)=(X-\alpha_1) \cdots (X-\alpha_n) .\]
		
		\begin{thm}
		\label{THM:algminpol}
		    Let $p$ be a prime, $k$ be a positive integer, and $f$ be a squarefree polynomial in $L_n$, let $R=\FpE[X]/(f)$, and $\alpha \in R$. Then $M_{Y}(\alpha)=\Res(f,Y-\alpha)$ with the resultant computed with respect to $X$ and $M_{Y}(\alpha)$ can be computed in $O( n^5k^3 )$ operations. 
		\end{thm}
		
		\begin{proof}
		    Let $T(n)$ be the number of $\Fp$ operations to compute the product of two polynomials of degree $n$ over $\FpE$. By the straightforward algorithm for multiplying polynomials we have $T(n)=O((nk)^2)$. Recall that the resultant is given by the determinant of the Sylvester matrix which is a square matrix of $n+m$ entries. In this case the entries of this matrix are polynomials of degree less than $n$. It is well known that the determinant of an $i \times i$ matrix with entries in a ring $R$ can be computed in $O(i^3)$ ring operations, so $O((n+m)^3T(n+m))=O(n^5k^3)$ $\Fp$-operations are required. 
		\end{proof}
		
	  Now we consider the issue of computing the composed operations. 
		% these should be taken straight from Loos
		
	  \begin{thm} 
		\label{THM:opsRes}
		    Let $f$ and $g$ be polynomials in $\Fq[X]$ then
				\begin{alignat*}{2}
		    f \oplus g  &= \Res(g(Y),f(X-Y),Y)     \\
				f \ominus g &= \Res(g(Y),f(X+Y),Y)     \\
				f \otimes g &= \Res(g(Y),Y^nf(X/Y),Y)  \\
				f \oslash g &= \Res(g(Y),f(XY),Y)      \\
				f ^ {(k)}   &= \Res(g(Y),X-Y^k,Y)      
				\end{alignat*}
		\end{thm}
		
		Theorem \ref{THM:opsRes} is related to determining the minimal polynomials of algebraic numbers. See [\citenum{loos}] or the exercises of Chapter 6 in [\citenum{von10modern}].
				
		\begin{cor}
		\label{COR:compTimes}
		    Let $\FpE$ be a finite field, and let $f$ and $g$ be polynomials over $\FpE$ of degree $n$ and $m$. 
				\begin{itemize}
				    \item The operations $f \oplus g, f \ominus g, f \otimes g,f \oslash g$ can be computed in $O(k^2(n+m)^5)$ $\Fp$-operations.
				    \item The operation $f ^ {(k)}$ can be computed in $O( k^2n^5 )$ $\Fp$-operations.
				\end{itemize}
		\end{cor}
		
		\begin{proof}
		    For the first statement we need to compute the resultant of two polynomials of degree $n$ and $m$. In this case the entries of the Sylvester matrix are polynomials of degree less than $n+m$. Hence $O(k^2(n+m)^5)$ $\Fp$-operations are needed. 
				For computing $f ^ {(k)}$ efficiently, we can compute $\alpha=X^k \pmod { \langle f,p \rangle }$ in $O( n^3\log(k) )$ $\Fp$-operations. Then $M(\alpha)=f^{(k)}$ and this by Theorem \ref{THM:algminpol} this can be computed in $O( k^2n^5 )$ $\Fp$-operations. 
		\end{proof}
					
    %
		%
    \subsection{Polynomials of Odd Degree}
		\label{SEC:OddDeg}
		%
		%
		
		In this section we give two algorithms for factoring odd degree polynomials over $\Fp$ with a certain property deterministically and unconditionally and prove their correctness. These are Algorithm \ref{ALGO:ODDDEG} and Algorithm \ref{ALGO:ODDDEG3}. At the end of this section we apply these algorithms to the factorization of random polynomials over $\Fp$.
				
		Let $s=\nu_2(p-1)$ and $m=(p-1)/2^s$. Algorithm \ref{ALGO:ODDDEG} factors any polynomial $f$ of odd degree so that $X^m \pmod{\langle f,p \rangle} \not\in \Fp$. Algorithm \ref{ALGO:ODDDEG} makes use of the following algorithms: 
		\begin{itemize}
		    \item $M(\beta)$ : let $R=\Fp[X]/(f)$ and $\beta \in R$ then $M(\beta)$ is the minimal polynomial of $\beta$
		    \item BASE : given $f=f_1^{e_1} \cdots f_k^{e_k}$ returns $f_1 \cdots f_k$                                    		
		    \item NON\_FLAT : Algorithm \ref{ALGO:NONFLAT}                                                       
		\end{itemize}
		\begin{singlespace}
		\begin{algorithm}[H] 
		\label{ALGO:ODDDEG}
		\caption{ODD\_DEG}
		\DontPrintSemicolon
		    Input : $p,f$ \;
				\hspace{2mm} $p$ a prime \;
				\hspace{2mm} $f \in L_n$ so that $f$ is squarefree \;	
			  Output : FAIL if $f$ cannot be factored, otherwise a nontrivial factor of $f$ \;
				\;
        $n=\deg(f)$ \;
        $s=\nu_2(p-1)$ \;
		    $m=(p-1)/2^s$ \;
        $\alpha= X^m \pmod {\langle f,p \rangle}$ \;    
				\If{$\alpha \in \Fp$}{
				    Return FAIL \;
				}
        \While{$ \deg(\alpha) \not= 0 $}{
            $y=\alpha \pmod {\langle f,p \rangle}$ \;
            $\alpha=\alpha^2 \pmod {\langle f,p \rangle}$ \;
        }
        \tcc{Compute the minimal polynomial of $y$. This polynomial has 2 distinct roots in $\Fp$} 
        $v =M(y)$ \;
			  $b =\textrm{BASE}(v,p)$ \;
        $v =\textrm{NON\_FLAT}(v,b,p)$ \;
			  \tcc{$r$ is a root of $v$. We have that $r$ is a square root of $\alpha$ in $\Fp$} 
				$r=-v(0)$ \;
        Return $\gcd(y-r,f)$ \;
		\end{algorithm}
	  \end{singlespace}
		\vspace{5mm}	
		For example, let $p=113$, and $f=X^3+53X^2+83X+35$ over $\Fp$. As $113-1=7\cdot2^4$ we have $s=4$. Then $\alpha=42X^2+79X+96$, $\alpha^2=99X^2+43X+66$, and $\alpha^4=112$. The components of $\alpha,\alpha^2,\alpha^4$ are 16th, 8th, and 4th roots of unity respectively.  We note that none of the roots of $f$ are primitive $2^s$ roots of unity as $\alpha^4$ has all its components equal to $-1 \pmod p$. We let $y=99X^2+43X+66$. Then $v=X^3+98X^2+X+98$ and $b=X^2+1$. Applying NOT\_FLAT to $v$ gives the factor $X-98$ of $v$ so $r=98$ is a square root of -1 in $\Fp$. Finally, $\gcd(y-98, f)=X+48$ is a factor of $f$.
		
		\begin{thm}
    \label{THM:ODDDEGTIME}
        Let $f \in L_n$ for $n$ odd, and let $m,s$ be such that $p-1=m2^s$. If $X^m \pmod f \not\in \Fp$ then Algorithm \ref{ALGO:ODDDEG} factors $f$ deterministically in $O( \log(p)n^2 + n^5)$ operations. 
    \end{thm}
		
		\begin{proof}
		    The first while loop terminates with $y$ such that $\deg(y)>0$ and $\zeta=y^2 \pmod {\langle f,p \rangle}$ is in $\Fp$. So $y$ has at least one distinct component. On the other hand $(y-\sqrt{\zeta})(y+\sqrt{\zeta})=0$ so the distinct components of $y$ are $\sqrt{\zeta}$ and $-\sqrt{\zeta}$ and so $y=(\pm \sqrt{\zeta},\ldots,\pm \sqrt{\zeta})$ . As the degree of $f$ is odd we cannot have $\sqrt{\zeta}$ and $-\sqrt{\zeta}$ appear the same number of times as components of $y$. Let $k_1$ and $k_2$ be the number of times that $\sqrt{\zeta}$ and $-\sqrt{\zeta}$ are components of $y$ respectively. Then $k_1>0,k_2>0$ and the minimal polynomial $m$ of $y$ is $(X-\sqrt{\zeta})^{k_1} (X+\sqrt{\zeta})^{k_2}$. As $m$ is not flat we can find a factor of $m$. Hence we can find a root $r=\sqrt{\zeta}$ of $v$. The element $y-r$ is zero on at least one component but not on every component. 
				
		    Computation of $X^m \pmod {\langle f,p \rangle}$ takes $O( \log(m)n^2 )=(\log(p)n^2)$ operations. Within the first while loop, computation of a square of $\alpha$ takes $O(n^2)$ operations. Hence computation of all the squares takes $O(\log(m)n^2)$. Computing BASE and NON\_FLAT both take $O(n^3)$ operations. Computation of the minimal polynomial is done by computing a single resultant which takes $O(n^5)$ operations.
		\end{proof}
		We note that Algorithm \ref{ALGO:ODDDEG} can also be applied to polynomials $f$ of even degree. However, even if $X^m \pmod{\langle f,p \rangle} \not\in \Fp$ there is no guarantee that the algorithm will produce a factor $f$. 
		
		We now turn to the second algorithm for factoring polynomials. This algorithm makes use of the composed operations $\otimes$ and $\oslash$. These operations can be used as a tool for FPFF in the following way. Given a polynomial $f$ we may compute $t=f \oslash f$. We then attempt a factorization of $t$ with some polynomial factorization algorithm $\mcA$. If $\mcA$ produces a factor $g$ of $t$ then we compute $r=g \otimes f$. The polynomial $r$ has at least one root in common with $f$. Whenever $r$ is not flat with respect to $f$ then a factor of $f$ can be computed in deterministic polynomial time.
		
		For example, if $f \in L_3$ over some finite field with roots $r_1,r_2,r_3$ then $h=(X-r_1/r_2)(X-r_1/r_3)(X-r_2/r_1)(X-r_2/r_3)(X-r_3/r_1)(X-r_3/r_2)$. Suppose the algorithm $\mcA$ returns $s=(X-r_1/r_2)(X-r_1/r_3)$ when given $h$ as input. Then 
		\begin{align*}
		    r=s \otimes f &=\bigl(X-r_1^2/r_2 \bigr)\bigl(X-r_1^2/r_3 \bigr)\bigl(X-r_1 \bigr)\bigl(X-r_1r_2/r_3 \bigr) \bigl(X-r_1r_3/r_2 \bigr) \bigl(X-r_1 \bigl) \\
		                  &=\bigl(X-r_1 \bigr)^2 \bigl(X-r_1^2/r_2 \bigr) \bigl(X-r_1^2/r_3 \bigr)\bigl(X-r_1r_2/r_3\bigr)\bigl(X-r_1r_3/r_2\bigr). 
		\end{align*}		
		\noindent Intuitively speaking we do not expect $r$ to be flat because this would require equality between one of $\left\{ r_1^2/r_2, r_1^2/r_3, r_1r_2/r_3, r_1r_3/r_2 \right\}$ and $r_2$. 
		
		% BALANCED
		\begin{mydef}
		\label{DEF:balanced}
		    Let $f \in L_n$ and let $R$ be the set of roots of $f$, $\gamma$ be an arbitrary element of $R$, and $t_1=(X-1)^{-n}(f \oslash f)$ then a factor $h$ of $t_1$ is \emph{$\otimes$-balanced} with respect to $f$ if for each root $a \in R$ 
				\[ {\#} \{ b \in R : h(a/b)=0 \} = {\#} \{ b \in R : h(\gamma/b)=0 \}. \]				 
		\end{mydef}	
		
		Suppose $t_1=h$. Clearly $t_1$ is balanced as each root appears the same number of times in the numerator and denominator of the roots of $h$. The number of numerator positions is $n(n-1)$ and the number of denominator positions is $n(n-1)$. The number of roots is $n$ so we have 
    \begin{equation}
		    {\#} \{ b \in R : h(a/b)=0 \} = n-1 \
    \end{equation}
		The degree of $h$ is sometimes enough to show $h$ is unbalanced. If $m=\deg(h)$ and if $n \nmid m$ then $h$ is not $\otimes$-balanced. As an example of a balanced polynomial, let $f=(X-r_1)(X-r_2)(X-r_3)$ then $t_1=(X-r_1/r_2)(X-r_1/r_3)(X-r_2/r_1)(X-r_2/r_3)(X-r_3/r_1)(X-r_3/r_2)$. Let $h=t_1$ then for $\gamma=r_1,r_2,r_3$, respectively,
		\begin{alignat*}{2}
		    \#\{ b \in R : h(r_1/b)=0 \} &&=\#\{r_2,r_3 \}=2    \\
		    \#\{ b \in R : h(r_2/b)=0 \} &&=\#\{r_1,r_3 \}=2    \\
		    \#\{ b \in R : h(r_3/b)=0 \} &&=\#\{r_1,r_2 \}=2    
		\end{alignat*}
		
		\noindent so $h$ is balanced. 
		
		As a second example, let $f=(X-r_1)(X-r_2)(X-r_3)(X-r_4)$ then $h=(X-r_1/r_2)(X-r_2/r_1)(X-r_3/r_4)(X-r_4/r_3)$ is balanced. 
		
		We may view polynomials that are factors of $(X-1)^{-n}(f \oslash f)$ as the arc polynomial of a graph. From this point of view, balanced polynomials correspond to regular subgraphs.
		
		For example, let $f=(X-r_1)(X-r_2)(X-r_3)(X-r_4)$ and consider the arc polynomial 
		\[ h=\left(X-\frac{r_1}{r_2} \right)\left(X-\frac{r_2}{r_1} \right)\left(X-\frac{r_2}{r_3} \right)\left(X-\frac{r_3}{r_2} \right)\left(X-\frac{r_3}{r_4} \right)\left(X-\frac{r_4}{r_3} \right)\left(X-\frac{r_4}{r_1} \right)\left(X-\frac{r_1}{r_4} \right). \]
		
		\noindent Then Figure \ref{FIG:ShitFig} gives the corresponding directed graph. 
		
		% how to make images not refer to the section they are in http://www.latex-community.org/forum/viewtopic.php?f=5&t=254
		\begin{center}
		    \begin{figure} 
						\input{C:/ttex/sep24SomeFuckingThing.txt} 
				    \caption{The graph of a balanced arc polynomial.}
				    \label{FIG:ShitFig}  
				\end{figure}
		\end{center}	
		
		\begin{lem}
		\label{LEM:bal}
		    Given polynomials $f \in L_n$ let $t=(X-1)^{-n}(f \oslash f)$. If $g$ is a balanced factor of $t$ with respect to $f$ then $t/f$ is also balanced. 
		\end{lem}
		
		\begin{proof}
		    Let $r_1,\ldots,r_n$ be the roots of $f$. Then 
				\begin{alignat*}{2}
				    t =&(X-r_1/r_2)(X-r_1/r_3) \ldots (X-r_1/r_n)                \\
						   &(X-r_2/r_1)(X-r_2/r_3) \ldots (X-r_2/r_n)                \\
							 & \vdotswithin{(X-r_2/r_1)(X-r_2/r_3) \ldots (X-r_2/r_n)} \\
							 &(X-r_n/r_1)(X-r_n/r_3) \ldots (X-r_n/r_{n-1})            
				\end{alignat*}
				Let $h=t/g$ then for any root $a$ of $f$ we have 
				\[ n-1 = {\#} \{ b \in R : g(a/b)=0 \} + {\#} \{ b \in R : h(a/b)=0 \} = {\#} \{ b \in R : g(a/b)=0 \} + k \]
				\noindent for some positive integer $k$. Hence 
				\[ {\#} \{ b \in R : g\left( \frac{a}{b}\right)=0 \} = n-1-k \]
				\noindent which shows that $g$ is balanced. 
		\end{proof}
						
		% 
		% NUM BACK SOLNS
		%
		
		Our strategy for polynomial factorization is as follows. Let $ f\in L_n$ and $t=(X-1)^{-n}(f \oslash f)$. If we can give a sufficient condition under which 1) any factor $g$ of $t$ that is unbalanced with respect to $f$ is such that $g \otimes f$ is not flat, and 2) we are given a polynomial factorization algorithm $\mcA$ then we can construct a polynomial factorization algorithm $\mcB$ that factors any polynomial $f$ for which $\mcA$ factors $t$. 
		
		\begin{lem}
		\label{LEM:numBackSolns}
		    Let $f \in L_n$ and $t=(X-1)^{-n}(f \oslash f)$ is squarefree. If $r_1$ and $r_2$ are any roots of $f$ then the only solution to $\left( r_1/r_2 \right) X = Y$ for $X$ and $Y$ roots of $f$ is $X=r_2$ and $Y=r_1.$
		\end{lem}
		
		\begin{proof}
		    Suppose there exist $s_1,s_2$ such that $s_1 \not=r_2$ or $s_2 \not=r_1$ such that $\left( r_1/r_2 \right) s_1 = s_2$ then $\left( r_1/s_2 \right)= \left( s_2/r_1 \right)$. But $\left( r_1/s_2 \right)$ is a root of $t$ which contradicts the fact that $t$ is squarefree. 
		\end{proof}
		
		\begin{cor}
		\label{COR:noBalNoFlat}
		    Let $f \in L_n$ such that $t=(X-1)^{-n}(f \oslash f)$ is squarefree, $R$ be the set of roots of $f$, and $h$ be a factor of  $(X-1)^{-n}(f \oslash f)$. Then $h \otimes f$ is flat if and only if $h$ is balanced. 
		\end{cor}
			
		\begin{proof}
		    Let $R$ be the set of roots of $f$. Then the roots of $h \otimes f$ have the form $ac/b$ where $a,b,c \in R$. 
		
		    Let $T(r)=\{ b \in R : h \left( r_1/b \right) =0  \} $ and let $N(r)=\{ s_1,s_2 \in R, r/b \in S: \left( r/b \right) s_1 =s_2 \}$. By Lemma \ref{LEM:numBackSolns} the only solution to $\left( r_1/r_2 \right) X = Y$ for $X$ and $Y$ roots of $f$ is $X=r_2$ and $Y=r_1$ so $\#T(r)=\#N(r)$. 
		
		    If $f$ is balanced then for any pair $r_1,r_2 \in R$ we have $\#N(r_1)=\#T(r_1) = \#T(r_2) = \#N(r_2)$ so $h \otimes f$ is flat. If $f$ is not balanced then their exist $r_1, r_2 \in R$ such that $\#N(r_1)=\#T(r_1) \not= \#T(r_2) = \#N(r_1)$ so $h \otimes f$ is not flat.
		\end{proof}
		
		Before giving Theorem \ref{THM:TwoOfFour} we give an example to motivate its proof. Suppose we are given the polynomial $f = (X-r_1)(X-r_2)(X-r_3)(X-r_4)(X-r_5)(X-r_6)(X-r_7)$ where $r_1,\ldots,r_7 \in \Fp$ such that $p \equiv 3 \pmod 4$ and 
		\[ \ind\left(r_1\right) \equiv \ind\left(r_2\right) \equiv \ind\left(r_3\right) \equiv 0 \pmod 2  \quad\quad \ind\left(r_4\right) \equiv \ind\left(r_5\right) \equiv \ind\left(r_6\right) \equiv \ind\left(r_7\right) \equiv 1 \pmod 2. \]
		
		\noindent There are $7\cdot6=42$ pairs of distinct roots. Let $v_{i,j}=\ind(r_i)-\ind(r_j) \pmod 2$. We can form two subgraphs $G_0,G_1$ of the complete graph on vertices $1,\dots,7$ where $r_i$ corresponds to vertex $i$ and $G_0$ has the arc $[i,j]$ when $v_{i,j}=0$ and $G_1$ has the arc $[i,j]$ when $v_{i,j}=1$. See Figure \ref{dontFail1} and Figure \ref{dontFail2}.
		\begin{center}
		    \begin{figure} \input{C:/ttex/QuoGraphEx1.txt} \caption{Difference of indexes equal to zero.} \label{dontFail1} \end{figure}
        \begin{figure} \input{C:/ttex/QuoGraphEx2.txt} \caption{Difference of indexes equal to one.}  \label{dontFail2} \end{figure}
		\end{center}
		An interesting property of these graphs is that they are not regular. In the graph in Figure \ref{dontFail2} the vertices $1,2,3$ have 4 arcs in and out, and the other vertices have 3 arcs in and out.  The arc polynomials of $G_0$ and $G_1$ with respect to multiplication are $g_0=t_0t_0^{\ast}$ and $g_1=t_1t_1^{\ast}$ where  
		\begin{alignat*}{2}
				t_0 =& \left(X-\frac{r_1}{r_2}\right)\left(X-\frac{r_1}{r_3}\right)\left(X-\frac{r_2}{r_3}\right) \left(X-\frac{r_4}{r_5}\right)\left(X-\frac{r_4}{r_6}\right)\left(X-\frac{r_4}{r_7}\right)\left(X-\frac{r_5}{r_6}\right) \\
				     & \cdot\left(X-\frac{r_5}{r_7}\right)\left(X-\frac{r_6}{r_7}\right),                                                     \\
		    t_1 =& \left(X-\frac{r_1}{r_4} \right)\left(X-\frac{r_1}{r_5}\right)\left(X-\frac{r_1}{r_6}\right)\left(X-\frac{r_1}{r_7}\right)\left(X-\frac{r_2}{r_4}\right)\left(X-\frac{r_2}{r_5}\right)\left(X-\frac{r_2}{r_6}\right)  \\ 
		         & \cdot\left(X-\frac{r_2}{r_7}\right)\left(X-\frac{r_3}{r_4}\right)\left(X-\frac{r_3}{r_5}\right)\left(X-\frac{r_3}{r_6}\right)\left(X-\frac{r_3}{r_7} \right) .
		\end{alignat*}
		
		Let $t=(X-1)^{-n}(f \oslash f)$, $m=(p-1)/2$, and $\alpha=X^m \pmod f$ then by Lemma \ref{THM:diffOrds} $g_0=\gcd(\alpha-1,t)$ and $g_1=\gcd(\alpha+1,t)$. The polynomials $t_0$ and $t_1$ are not balanced so we can construct a factor of $f$. This idea is naturally extended to factoring a large class of odd degree polynomials by Theorem \ref{THM:TwoOfFour}.	
		
		We recall some notation from Chapter \ref{CH:Background} that is used in the proof of Theorem \ref{THM:TwoOfFour}. We defined
		    \[ \ind(f)=\{ \ind(r_1),\ldots,\ind(r_n)\} \] 
		
		\noindent where $\ind(r_1),\ldots,\ind(r_n)$ are computed with respect to $g$. 
		
		For $x \in \Fq$ and for $l$ a prime dividing $q-1$ define $\ind(x)[l^k]$ be the $k$th digit of $\ind(x)$ expressed in base $l$ with the lowest digit defined as the 0th digit. For $f \in L_n$ with roots $r_1,\ldots,r_n$ define
		
		\[ \ind(f)[l^k]=\{ \ind(r_1)[l^k],\ldots,\ind(r_n)[l^k] \}. \] 
		
		Like Algorithm \ref{ALGO:ODDDEG}, Algorithm \ref{ALGO:ODDDEG3} factors some polynomials of odd degree over prime fields. There are more conditions required for Algorithm \ref{ALGO:ODDDEG3} to guarantee that a factor is found than for Algorithm \ref{ALGO:ODDDEG}. However, Algorithm \ref{ALGO:ODDDEG3} is related to a method used in the next chapter. Algorithm \ref{ALGO:ODDDEG3} makes use of the following algorithms:
		\begin{itemize}
		    \item NON\_FLAT : Algorithm \ref{ALGO:NONFLAT} 
				\item IS\_SQF : Takes a polynomial $f$ as input and returns true if $f$ is squarefree and false otherwise
		\end{itemize}
		
		\begin{singlespace}
		\begin{algorithm}[H] 
		\DontPrintSemicolon
		\label{ALGO:ODDDEG3}
		\caption{ODD\_DEG2}
		\DontPrintSemicolon
		    Input : $p,f$ \;
				\hspace{2mm} $p$ a prime \;
				\hspace{2mm} $f$ a squarefree polynomial in $L_n$ over $\Fp$ \;	
			  Output : if $X^m \pmod {\langle f,p \rangle} \not\in \Fp$ and $(X-1)^{-n}(f \oslash f)$ is squarefree returns a nontrivial factor of $f$ \;
				\;
        $s=\nu_2(p-1)$ \;
				$m=(p-1)/2^s$ \;			
        $\alpha= X^m \pmod {\langle f,p \rangle}$ \;
        \If{$\alpha \in \Fp$}{
				    \tcc{in this case all the components of $\alpha$ are $m$th roots of unity}
            Return FAIL \;
        }
				\Else{
            $t = (X-1)^{-n}(f \oslash f)$ \;
						\lIf{$\textrm{ IS\_SQF}(t,p)$=false}{
			          Return FAIL \;
			      }
						$z= X^m \pmod {\langle t,p \rangle}$ \;
            \While{$z \not\in \Fp$}{
						    $y=z$ \;
                $z = z^2 \pmod {\langle t,p \rangle} $ \;
            }
            $g_1 = \gcd(y-1,t)$ \;
						$b=g_1 \otimes f$ \;
            $f_1 = \textrm{NON\_FLAT}(b, f, p)$ \;
            Return $f_1$ \;
        }
		\end{algorithm}
		\end{singlespace}	
		\vspace{5mm}			
		We illustrate the Algorithm \ref{ALGO:ODDDEG3}. Let $\Fp$ be the prime field with $p = 1033$ then $p-1=m \cdot 2^3$ for $m=129$ and $r_1=33, r_2=67, r_3=308, r_4=327, r_5=409$ and $f = (X-r_1)(X-r_2)(X-r_3)(X-r_4)(X-r_5)$. Clearly $f$ is squarefree. We let $\alpha=X^m \pmod f$. The element $z \not\in \Fp$. However, $z^2=355$ and so $z=355$ is a 4th primitive root of unity. This tells us that 
		    \[ \ind(f) = [\ind(r_1), \ind(r_2),\ind(r_3), \ind(r_4),\ind(r_5)] \equiv k[1,1,1,1,1] \pmod{2^2} \] 
		for some integer $k$ and there exist $1 \leq i < j \leq 5$ so that $\ind(r_i) \not\equiv \ind(r_j) \pmod{2^3}.$ Let $t=(X-1)^{-5}(f \oslash f)$. We have
		\begin{alignat*}{2}	
		t  &=X^{20}+180X^{19}+21X^{18}+54X^{17}+598X^{16}+555X^{15}+228X^{14}+915X^{13}+393X^{12}+548X^{11} \\
		   &+119X^{10}+548X^{9}+393X^{8}+915X^{7}+228X^{6}+555X^{5}+598X^{4}+54X^{3}+21X^{2}+180X+1.
		\end{alignat*}		
		We verify that $t$ is squarefree. Then $z=X^m \pmod t \not\in \Fp$ and $z^2=1$ so by Theorem \ref{THM:diffOrds} $z-1$ splits $t$. Let $h_0=\gcd(z-1,t)$ and $h_1=\gcd(z+1,t)$. We have
		\begin{align*}
		h_0 &= X^{8}+652X^{7}+888X^{6}+444X^{5}+143X^{4}+444X^{3}+888X^{2}+652X+1, \\
		h_1 &= X^{12}+561X^{11}+76X^{10}+413X^{9}+318X^{8}+42X^{7}+338X^{6}+42X^{5}+318X^{4}+413X^{3} \\
				&+76X^{2}+561X+1.
		\end{align*}	
			
		We know that the first of these factors corresponds to all the pairs of roots $r_i,r_j$ for which the difference $\ind(r_i)[2^2]-\ind(r_j)[2^2] \equiv 0 \pmod 2$ and the second corresponds to all the pairs of roots $r_i,r_j$ for which the difference $\ind(r_i)[2^2]-\ind(r_j)[2^2] \equiv 1 \pmod 2$. As the degree of $h_1$ is not divisible by $n$ we have that $h$ is not balanced. Then $r=h_1 \otimes f$ is a degree 60 polynomial. Applying Algorithm \ref{ALGO:NONFLAT} to this polynomial we recover the factor $X^2+591X+68=(X-33)(X-409)=(X-r_1)(X-r_5)$.
		
		We can give a bit more detail about the roots of the factor we have recovered. We have $g=5$ is a primitive root in $\Fp$. Then $\ind(f)$ with respect to $g$ is $[\ind(r_1),\ind(r_2), \ind(r_3), \ind(r_4), \ind(r_5) ]=[579,263,327,871,595]$ and $\ind(f) \equiv [3,7,7,7,3] \pmod {2^3}$. Hence we see that the roots of $f$ that are in the factor $X^2+591X+68$ have index that is congruent to $3 \pmod {2^3}$. In the arc polynomial $h_1$ the vertices corresponding to $r_1$ and $r_5$ have three arcs in and three arcs out. These arcs join them the vertices $r_2,r_3,r_4$. Each of the vertices $r_2,r_3,r_4$ have two arcs in and two arcs out. These arcs join them to $r_1$ and $r_5$. As $r_1$ and $r_5$ have more arcs in arcs out than the vertices $r_2,r_3,r_4$ Algorithm \ref{ALGO:NONFLAT} returns $(X-r_1)(X-r_5)$. This concludes the example.
		
		\begin{thm}
    \label{THM:TwoOfFour}
        Let $f \in L_n$ for $n$ odd, and $t=(X-1)^{-n}(f \oslash f)$, and let $m$ be such that $p-1=m2^s$. If $t$ is squarefree, and $X^m \pmod f \not\in \Fp$ then Algorithm \ref{ALGO:ODDDEG3} factors $f$ deterministically in $\poly(n,\log(p))$ operations. More precisely the algorithm uses $O(n^{10}\log(p)^2+n^4\log(p)^3)$ operations. 
    \end{thm}
				
    \begin{proof}
					
				Let $t=(X-1)^{-n}(f \oslash f)$. The degree of $t$ is $n(n-1)$. Consider $\ind(f) \equiv (\ind(r_1),\ldots,\ind(r_n)) \pmod{2^s}$. Let $i$ be the largest positive integer so that for every pair of roots $r_a,r_b$ we have $\ind(r_a) \equiv \ind(r_b) \pmod {2^i}$. We have $i<s$ since $X^m \pmod f \not\in \Fp$. Then there is a pair of roots $r_a,r_b$ so that $\ind(r_a) - \ind(r_b) \equiv 0 \pmod {2^{i+1}}$ and a pair of roots $r_c,r_d$ so that $\ind(r_c) - \ind(r_d) \not\equiv 0 \pmod 2^{i+1}$. It follows that the order of $\ind(r_c) - \ind(r_d)$ is divisible by a larger power of 2 than the order of $\ind(r_a) - \ind(r_b)$ so by Theorem \ref{THM:diffOrds} we can get a factorization $t=g_0g_1$. Let 			
				\begin{alignat*}{2}
				    E_0 &= \{ [r_i,r_j] \in R : \ind(r_i)[2^{i+1}] - \ind(r_j)[2^{i+1}] \} \\
					  E_1 &= \{ [r_i,r_j] \in R : \ind(r_i)[2^{i+1}] - \ind(r_j)[2^{i+1}] \}.
				\end{alignat*}
				\noindent Then $g_0=\prod_{[r_i,r_j] \in E_0}{(X-r_i/r_j)}$ and $g_1=\prod_{[r_i,r_j] \in E_1}{(X-r_i/r_j)}$. We show neither of these is balanced by showing $g_1$ is not balanced. Let $R_0 = \{ r \in R : (\ind(r))[2^{i+1}] \equiv 0 \pmod 2 \}$ and $R_1 = \{ r \in R : (\ind(r))[2^{i+1}] \equiv 1 \pmod 2 \}$. These sets are a disjoint partition of $R$ and since $n$ is odd they do not have equal size. Every element of $R_0$ appears $(\#R_1)$ times in the first position of the elements of $E_1$ and $(\#R_2)$ times in the second position of the elements of $E_2$. Every element of $R_1$ appears $(\#R_0)$ times in the first position of the elements of $E_0$ and $(\#R_1)$ times in the second position of the elements of $E_0$. Hence $g_1$ is not balanced and so by Corollary \ref{COR:noBalNoFlat} and Algorithm \ref{ALGO:NONFLAT} a nontrivial factor of $f$ can be constructed in deterministic polynomial time.
				
				We now turn to the number of operations. We have $\alpha$ can be computed in $O(n^2\log(p)^3)$ by Theorem \ref{THM:runTimes}. Then $t$ can be computed in $O(n^3 T(n))=O(n^5)$ operations by Theorem \ref{COR:compTimes} where $T(n)$ is the number of operations to compute the product of two polynomials of degree $n$. As $t$ is a degree $n^2$ polynomial it can be tested if it is squarefree in $O(n^4\log(p)^2)$ by Theorem \ref{THM:runTimes}. Then $z$ can be computed in $O(n^4\log(p)^3)$ operations by Theorem \ref{THM:runTimes} and $g_1$ can be computed in $O(n^4\log(p)^2)$. Using Theorem \ref{COR:compTimes} we can compute $b$ in $O(n^{10}\log(p)^2)$ operations by Theorem \ref{COR:compTimes} and $f_1$ can be computed in $O(n^8\log(p)^2)$ by Theorem \ref{THM:NONFLATTime}.
				
		\end{proof}
		
		%
		% this remark pertains to each of the odd degree factorization algorithms
		%
		We remark that if we are allowed to use ERH then Theorem \ref{THM:TwoOfFour} is more easily proved. By Theorem \ref{THM:ERHNonres} a quadratic nonresidue can be constructed and by Theorem \ref{THM:vonzurGathen} $f$ can be factored in deterministic polynomial time. Note that an algorithm to factor \emph{arbitrary} odd degree polynomials in $L_n$ under ERH would imply that any polynomial over $\Fp$ can be factored in deterministic polynomial time by Theorem \ref{THM:Ronyai} (for generic polynomials this theorem requires GRH to produce a factor, however, for the case that $n$ is even we only need to construct a quadratic nonresidue so ERH is sufficient).
							
		Although so far we have restricted our attention to the case that $n$ is odd Algorithm \ref{ALGO:ODDDEG} can also be run on even degree polynomials. In this case the conditions of the odd degree case do not guarantee that a factor is produced. However, intuitively speaking, the algorithm in the proof of Algorithm \ref{ALGO:ODDDEG} factors many polynomials of both odd and even degree. The following theorem shows the probability the algorithm produces a factor of random element of $L_n$ is better than the probability that the Algorithm \ref{ALGO:cz} produces a factor of a random element of $L_n$ modulo some primes. In particular, it is better when $p \equiv 1 \pmod 4$. 
		
		For any $f \in L_n$ such that $f^{(p-1)/2} \not\in \Fp$ then $f$ can be factored unconditionally by Theorem \ref{THM:diffOrds}. This kind of factorization is a special case of Algorithm \ref{ALGO:cz}. If we let $M$ be the subset of $L_n$ for which Algorithm \ref{ALGO:cz} algorithm fails to output a factor then the probability that a random element of $L_n$ is in $M$ is $1/2^{n-1}$ since factorization occurs when every root is a quadratic residue or every root is a quadratic nonresidue. A random element of $\FP$ is a quadratic nonresidue with probability $1/2$ by Corollary \ref{COR:resProb}.
		
		% source: Wiki central binomial coeff
		\begin{lem}
		\label{LEM:binB}
		    Let $n$ be a positive integer then $\binom{2n}{n} \leq 4^n.$
		\end{lem}
		
		\begin{proof}
		    From Stirling's approximation we have $n! \leq en^{n+1/2}e^{-n}$. Then
				\begin{alignat*}{2}
				\binom{2n}{n} &= \frac{(2n)!}{(n!)^2} \leq \frac{e(2n)^{2n+1/2}e^{2n}}{e^2(2n)^{2n+1}e^{2n}} = \frac{4^n}{\sqrt{2}en^{1/2}} \leq 4^n 
				\end{alignat*}				
		\end{proof}
			
		\begin{thm} 
		    Let $\mcA$ denote Algorithm \ref{ALGO:ODDDEG}. Let $S$ be the set of polynomials in $L_n$ so $\mcA$ fails to produce a factor. Suppose $p-1=m2^s$ for odd $m$. The probability that a random element of $L_n$ is in $S$ is less than $ \frac{1} {2^{n(s-1)}} $.  
		\end{thm}
		
		\begin{proof}
		    Let $P(f \in S)$ be the probability that $f$ is in $S$. We have 
				
				\[ P(f \in S)=P(f^m \not\in \Fp)P(f \in S \mid f^m \not\in \Fp). \] 
				
				\noindent We form the $n \times s$ array $B$ with entries in $\{0,1 \}$ where $b_{i,j}=\ind(r_i)[2^j]$. Then $f^m \not\in \Fp$ if and only if there is a column of $B$ not equal to $k[1,\ldots,1]$ for $k \in \{0,1 \}$. For any $0 \leq z \leq 2^s-1$ there are an equal number of elements in the set $\{ x \in \Fp : \ind(x) \equiv z \pmod {2^s} \}$ so the probability that a given column of $B$ has the form $k[1,\ldots,1]$ for $k \in \{0,1 \}$ is $1/2^n$ and the probability that every column of $B$ has this form is $1/2^{ns}$.
				
				Given that $f^m \not\in \Fp$ let $i$ be the least positive integer so that two entries in the $i$th column are distinct. Then $\mcA$ only fails to produce a factor of $f$ if the $i$th column has the same number of zeroes as it does ones. Hence by \ref{LEM:binB}
				\[ P(f \in S \mid f^m \not\in \Fp)=\binom{2n}{n} 2^{-n} \leq 4^n2^{-n}=2^n \]
				Then $P(f \in S) = P(f^m \not\in \Fp)P(f \in S \mid f^m \not\in \Fp) \leq \frac{2^n}{2^{ns}} =\frac{1} {2^{n(s-1)}}.$
		\end{proof}
		
		%
		%
    \subsection{Factoring Polynomials with $\gcd(n,\phi(p-1))=1$  }
		\label{SEC:CoDeg}
		%
		%
		
		Suppose we are given the polynomial $f=(X-\omega)(X-\omega^2)(X-\omega^4)$ to factor modulo a prime $p$ in coefficient form with $\omega$ a primitive 5th root of unity. We can try to factor this polynomial using the composed power operation. We compute $f^{(2)}=(X-\omega^2)(X-\omega^4)(X-\omega^3)$ and as two of the roots of this polynomial are roots of $f$ we can factor $f$ by computing its greatest common divisor with $f^{(2)}$.
		
		A more general version of this idea would be to compute $h_k=\gcd(f,f^{(k)})$ for $k=1,2,\ldots$ until $h_k$ is a nontrivial factor of $f$. It is clear that $h_1,h_2,\ldots$ is a periodic sequence and the period divides $p-1$. 
		
		We want to construct the set of all polynomials of this type that cannot be factored by the method above. Consider the case where $f$ is a polynomial in $L_n$ with roots that are distinct $l$th primitive roots of unity for prime $l$. We note that $\ind(f)$ is a subset of $\mathbb{Z}^{*}_{l-1}$. 
		
		Let $C_d$ denote the multiplicative cosets of $\mathbb{Z}^{*}_{l-1}$. Then the elements of $C_d$ form a partition of $\mathbb{Z}^{*}_{l-1}$. If $k \in \mathbb{Z}^{*}_{l-1}$ and $c_1,c_2$ are elements of the same coset then $kc_1$ and $kc_2$ are in the same coset. Let $\ind(f)[l]=[z_0,\ldots,z_n]$ be a multiplicative coset of a subgroup of $\mathbb{Z}^{*}_l$. For any positive integer $c$ that is not divisible by $l$ we have $\ind(f^{(c)})[l]=[cz_0,\ldots,cz_n]$ is also a coset of $H$. Hence the polynomials $f$ that we cannot factor by computing $h_k=\gcd(f,f^{(k)})$ for $k=1,2,\ldots$ are the polynomials where $\ind(f)$ is a coset of $\mathbb{Z}^{*}_{l-1}$.
			
		Heuristically, the least $k>2$ such that $\gcd(f,f^{(k)})>1$ could be large. Algorithm \ref{ALGO:CODEG} improves on the efficiency of this idea. In Theorem \ref{THM:CoDeg} it is shown that any squarefree polynomial in $L_n$ with $\gcd(n,\phi(p-1))=1$ is factored by Algorithm \ref{ALGO:CODEG}. As in Theorem \ref{THM:SmoothFac} the number of operations of this algorithm depends on $S(p-1)$ but Algorithm \ref{ALGO:CODEG} is unconditionally deterministic, unlike Theorem \ref{THM:SmoothFac} which is conditional on ERH.
		
		Recall that if $f$ is an element of $L_n$ over $\Fp$ then $f$ is a univariate polynomial in $\Fp[X]$. Algorithm \ref{ALGO:PRIMEPOWFAC} is an auxiliary algorithm for Algorithm \ref{ALGO:CODEG}. Algorithm \ref{ALGO:PRIMEPOWFAC} makes use of the following algorithms: 
		\begin{itemize}
		    \item $M(\alpha)$ : the minimal polynomial of $\alpha$ 
		    \item IS\_SQF : returns true if a polynomial is squarefree and false otherwise 
		\end{itemize}
		
		\begin{singlespace}
		\begin{algorithm}[H] 
		\label{ALGO:PRIMEPOWFAC}
		\caption{PRIME\_POW\_FAC}
		\DontPrintSemicolon		
				Input: $p,l,f$ \;
				\hspace{2mm} $p$ a prime \;
				\hspace{2mm} $l$ a prime dividing $p-1$ so that $X^{(p-1)/l^s} \not\in \Fp$ \;
				\hspace{2mm} $f \in L_n$, so that $f$ is squarefree and $\gcd(n,\phi(p-1))=1$ \;
				Output: a factor of $f^{(de)}$ with $d,e$ as defined below \;
				\;
        $s=\nu_l(p-1)$\;
				$d=(p-1)/l^s$ \;
        $e= d^{-1} \pmod{l^s}$\;
        $\alpha=X^{(de)} \pmod{\langle f,p \rangle}$\;
				\tcc{$M(\alpha)$ is equal to $f^{(de)}$}
        $g=M(\alpha) $\;
				\tcc{initialize $A$ as a tuple with $g$ as its only element}
        $A=[g] $\;
        \tcc{compute the minimal polynomial of $\alpha$ and test if it is squarefree} 
        \While{ $IS\_SQF(g,\Fp) $}{
            $\beta=\alpha $\;
            $\alpha=\alpha^l \pmod{\langle f,p \rangle}$\;
            $g=M(\alpha)$\;
						\tcc{add the element $m$ to the tuple $A$}
            $A=A \cup g$\;
				}
        \tcc{when we exit the while loop $A$ is a tuple of $z$ elements $[A_1,\ldots,A_{z}]$ and $\deg(M(\beta))=n$} 
				% note that minB does not get stored in A
				$z=\#A$ \;
        $v=M(\beta)$ \; 
				\tcc{$c$ is a product of the roots of $v$}
        $c=(-1)^n v(0)$ \;
        $b=n^{-1} \pmod{l^s}$ \;
				\tcc{the constant $y$ is used to manipulate the roots of the polynomial $v$}
        $y=c^b $ \;
				\tcc{by evaluating $v$ at $yX$ make a new polynomial so that }
				\tcc{for every root $r$ of $v$ we have $y^{-1}r$ is a root of the new polynomial}
        $v=v(yX)$ \; 
        \tcc{test if $X=1$ is a root modulo $p$. In this case $X-y$ is a root of $m$}
        $r=v(1)$ \;
        \uIf{$r=0$}{
            $h=X-y$;
        } 
        \For{$i$ \textup{\textbf{from}} $2$ \textup{\textbf{to}} $l-1$}{
            $w=v^{(i)}$ \;                
            $h=\gcd(v,w)$ \;
            \uIf{$0<\deg(h)$ and $\deg(h)<n$}{
                Break \;
            }
        }
        \uIf{$\deg(h)=0$ or $\deg(h)=n$}{
            \tcc{in this case $\ind(h)$ is a coset of $\mathbb{F}^*_{l}$ } 
            Return FAIL \;
        }
        \tcc{$h$ is a nontrivial factor of $A_{z-1}$. We divide the constant $y$ out from the roots of $h$} 
        $h=h(y^{-1}X)$ \; 
        \For{$i$ \textup{\textbf{from}} 2 \textup{\textbf{to}} $z-1$}{ 
            $h=h(X^l)$ \;
            $h=\gcd( a_{z-i}, h ) $ \;
        }
    Return $h$ \;
	  \end{algorithm}	
		\end{singlespace} 
		\vspace{5mm}	
		
		We note that Algorithm \ref{ALGO:PRIMEPOWFAC} is similar to Algorithm \ref{ALGO:diffords} and Algorithm \ref{ALGO:INDFAC}. Each of these algorithms requires repeatedly raising an element $\alpha$ to the power $l$ until $\alpha$ is in $\Fp$. For each such $\alpha$ we store an $l$th root of $\alpha$ that is not in $\Fp$. The main difference between these algorithms is in how a factor of the polynomial $f$ is found using the $l$th root of $\alpha$. 
				
		Algorithm \ref{ALGO:CODEG} factors polynomials with degree coprime to $\phi(p-1)$. Algorithm \ref{ALGO:CODEG} makes use of the following algorithms:
		\begin{itemize}
		    \item FIND\_PRIME : finds the smallest prime $l$ so that $\alpha^{(p-1)/l^s} \not\in \Fp$ for $s=\nu_l(p-1)$
		    \item PRIME\_POW\_FAC : Algorithm \ref{ALGO:PRIMEPOWFAC} 
	  \end{itemize}
	
		% Corresponding Maple code is in the file Oct17.txt				
		\begin{singlespace}
		\begin{algorithm}[H] 
		\label{ALGO:CODEG}
		\caption{CO\_DEG}
		\DontPrintSemicolon	
				Input: $p,f$ \;
				\hspace{2mm} $p$ prime \;
				\hspace{2mm} $f \in L_n$, so that $f$ is squarefree and $\gcd(n,\phi(p-1))=1$ \;
				Output: a factor of $f$ \;
				\; 
        $l=\textrm{FIND\_PRIME}(f,p) $\;   
        $s=\nu_l(p-1)$ \;
        $d=l^s$ \;
        $e=d^{-1} \pmod {(p-1)/l^s}$ \; 
        $t=f^{(de)}$ \;
        $h=\textrm{PRIME\_POW\_FAC}(f,l,p)$ \;
        $y=h \otimes t$ \;
        $a=\gcd(y,f)$ \;
        Return $a$ \;
	  \end{algorithm}	
		\end{singlespace} 
		\vspace{5mm}		
				
		For example, let $p = 13751$, and $\omega = 15$ a $5^4$th primitive root of unity. In order to make the example clearer we show polynomials in their factored form. Let $f=(X-\omega)(X-{\omega}^{3+5})(X-{\omega}^{4+5+5^2})$. The prime found by FIND\_PRIME is $5$. As all the roots are $5^4$th primitive roots of unity the polynomial $t$ in Algorithm \ref{ALGO:CODEG} is $(X-1)^3$. The list of minimal polynomials $A$ in Algorithm \ref{ALGO:PRIMEPOWFAC} is 
		\begin{alignat*}{2}
		     [a_1,a_2,a_3,a_4] = &\bigl[\bigl(X-\omega    \bigr)\bigl(X-{\omega}^{3+5} \bigr)\bigl( X-{\omega}^{4+5+5^2} \bigr),                  \\
		                         &\bigl(X-\omega^{5}  \bigr)\bigl(X-{\omega}^{3\cdot 5+5^2}\bigr)\bigl(X-{\omega}^{4\cdot 5+5^2+5^3}\bigr),    \\
		                         &\bigl(X-\omega^{5^2}\bigr)\bigl(X-{\omega}^{3\cdot 5^2+5^3}\bigr)\bigl(X-{\omega}^{4\cdot 5^2+5^3}\bigr),    \\
		                         &\bigl(X-\omega^{5^3}\bigr)\bigl(X-{\omega}^{3\cdot 5^3}\bigr)\bigl(X-{\omega}^{4\cdot 5^3}\bigr) \bigr]. 
		\end{alignat*}	
		Let $Z=\ind(a_4)[5^3]=\{1,3,4\}$. The least integer $i$ so that $Z$ and $iZ$ have an intersection that is non-empty but does not equal $Z$ is $i=2$. In this case $Z \cap iZ=\{ 1,3 \}$. Hence $\gcd(a_4,a_4^{(2)})=(X-\omega^{5^3})(X-{\omega}^{3\cdot 5^3})$. In the next iteration of the loop the polynomial $g$ becomes $(X-\omega^{5^2})(X-{\omega}^{3\cdot 5^2+5^3})$ then $(X-\omega^{5})(X-{\omega}^{3\cdot 5+5^2})$, and then $(X-\omega)(X-{\omega}^{3+5})$. Algorithm \ref{ALGO:PRIMEPOWFAC} returns this $g$. 
		Then in Algorithm \ref{ALGO:CODEG} we have $y=h \otimes t=((X-\omega)(X-{\omega}^{3+5}))^3$. Finally, $a=\gcd(y,f)=(X-\omega)(X-{\omega}^{3+5})$ is a nontrivial factor of $f$. 
		
		Unfortunately there can be many polynomials of a given degree that this algorithm does not factor. For example let $p$ be a prime so that $p-1$ is divisible by 7. Let $\omega$ be a generator of the subgroup of elements whose order is not divisible by 7 and $\zeta$ be a primitive seventh root of unity. Then the algorithm will fail to factor polynomials of the form
		\[ f=\bigl(X-\omega^i \zeta \bigr)\bigl(X-\omega^i \zeta^2 \bigr)\bigl(X-\omega^i \zeta^4 \bigr). \]
		\noindent for any nonnegative integer $i$. Given this $f$ the polynomial $g$ in Algorithm \ref{ALGO:PRIMEPOWFAC} is 
		\[ g=\bigl(X-\zeta \bigr)\bigl(X-\zeta^2 \bigr)\bigl(X-\zeta^4 \bigr). \]
		The set $\{1,2,4 \}$ is a multiplicative subgroup of $\mathbb{Z}^{*}_6$ so Algorithm \ref{ALGO:PRIMEPOWFAC} does not find a factor of it. 
		
    For $x$ a positive integer let $\rad(x)$ denote the prime factors of $x$. Regarding the statement of Theorem \ref{THM:CoDeg} we note that $\gcd(n,\phi(p-1))=1$ if and only if $\gcd(n,\rad(\phi(p-1)) )=1$.
			
		\begin{thm}
		\label{THM:CoDeg}
		    Let $p$ be a prime, and $f$ be a squarefree polynomial in $L_n$. If $\gcd(n,\phi(p-1))=1$ then Algorithm \ref{ALGO:CODEG} factors $f$ deterministically in $O(n^{5}\log(p)S(p-1))$ operations.
		\end{thm}	
		
	  Theorem \ref{THM:CoDeg} is a direct result of Theorem \ref{THM:pp} and Lemma \ref{LEM:coOrd}.
		
		\begin{thm}
		\label{THM:pp}
		    Let $p$ be a prime, and $f$ be a squarefree polynomial in $L_n$. Let $l$ be a prime dividing $p-1$, $s=\nu(q-1)$, $d=(p-1)/l^s$. If $\gcd(n,\phi(p-1))=1$ and $X^d \pmod{\langle f,p \rangle} \not\in \Fp$ then Algorithm \ref{ALGO:PRIMEPOWFAC} factors $f$ deterministically in $O(n^{5}\log(p)S(p-1))$ operations.
		\end{thm}	
		
		\begin{proof}
		    Let $p=l_1^{s_1}\cdots l_k^{s_k}$. The condition $\gcd(n,\phi(p-1))=1$ implies 
				\[ \gcd(n,\rad(\phi(p-1)))=\gcd \left(n, \Bigl( \prod_{i=1}^n{l_i} \Bigr) \Bigl( \prod_{i=1}^n{(l_i-1 )} \Bigr) \right)=1.\] 

			  Hence $n$ is coprime to $l$ and $l-1$ for each prime $l$ dividing $p-1$. In Algorithm \ref{ALGO:PRIMEPOWFAC} we start with a general polynomial $f$ of degree $n$. 
		    \begin{alignat*}{5}                                               
        \ind(f) =       & \bigl[ a_{0,0}   &&+ a_{0,1}l        && +               \cdots &&+  a_{0,s-1}l^{s-1}         \\
                        &        a_{1,0}   &&+ a_{1,1}l        && +               \cdots &&+  a_{1,s-1}l^{s-1} ,       \\
                        &                  &&\vdotswithin{+}   && \vdotswithin{+}        &&\vdotswithin{+}             \\
                        &        a_{n-1,0} &&+ a_{n-1,1}l      && +               \cdots &&+  a_{n-1,s-1}l^{s-1} \bigr].
	    	\end{alignat*}	
		    Let $i$ be the least positive integer so that $\ind(f)[l^i]$ is a nonzero tuple. Using a composed power we construct the polynomial $v$ of degree $n$ from $f$. The roots of $v$ are $l^i$th primitive roots of unity for some $i$ and the index of $v$ has the form		
		    \begin{alignat*}{5}
		    \ind(v) =        & \bigl[ w_{i}l^{i} &&+ w_{i+1}l^{i+1} &&+ \cdots          &&+  w_{s-2}l^{s-2} &&+ z_0l^{s-1} ,  \\
                         & w_{i}l^{i}        &&+ w_{i+1}l^{i+1} &&+ \cdots          &&+  w_{s-2}l^{s-2} &&+ z_1l^{s-1} ,  \\
                         &                   &&\vdotswithin{+}  &&\vdotswithin{+}   &&\vdotswithin{+}   &&\vdotswithin{+} \\
                         & w_{i}l^{i}        &&+ w_{i+1}l^{i+1} &&+ \cdots          &&+  w_{s-2}l^{s-2} &&+ z_{n-1}l^{s-1} \bigr]
		    \end{alignat*}
        \noindent with $w_i,\ldots,w_{s-2}$ and $\{z_0,\ldots,z_{n-1}\}$ in $\mathbb{F}_l$ and such that $w_i \equiv 0 \pmod l$ implies $w_j \equiv 0 \pmod l$ for all $i \leq j \leq s-2$. Let $R=[w_{i},w_{i+1},\ldots,w_{s-2}]$. Let $e=d^{-1} \pmod {l^s}$. The condition $X^d \pmod{\langle f,p \rangle} \not\in \Fp$ implies that $X^{de} \pmod{\langle f,p \rangle} \not\in \Fp$ and so there exist a pair of distinct elements in $\{z_0,\ldots,z_{n-1} \}$. There are two cases to consider:
		    \begin{itemize}
		        \item $R=0$, 
		        \item one element in $R$ is nonzero.
		    \end{itemize}
		    Algorithm \ref{ALGO:PRIMEPOWFAC} reduces the second case to the first case in the following way. Consider the constant term of $v$. Let $z=(-1)^n v(0)$, and $v_1,\ldots,v_n$ be the $n$ elements of the tuple $\ind(v)$. Let $t=\sum_{i=0}^n{v_i}$ then $z=\omega^{t}$ for some $l^s$ primitive root of unity $\omega$ and 
		    \[ t=n \left( w_{i}l^{i} + w_{i+1}l^{i+1} + w_{i+2}l^{i+2} + \cdots +  w_{s-2}l^{s-2} \right) + rl^{s-1} \]
		    for some positive integer $r$ with $0 \leq r<l$. Let $b=n^{-1} \pmod {l^s}$ then 
		    \[ tb= \left( w_{i}l^{i} + w_{i+1}l^{i+1} + w_{i+2}l^{i+2} + \cdots +  w_{s-2}l^{s-2} \right) + brl^{s-1}. \]		
		    We redefine $v$ as $v=v(\omega^{tb})=v(yX)$ where $y$ is given in the algorithm. Then 
				\[ \ind(v) =[ z_0l^{s-1}, z_1l^{s-1}, \ldots, z_{n-1}l^{s-1} ]. \]
				Let $Z = \{ bz_0,bz_1,\ldots,bz_{n-1} \}$. At this point there are two cases to consider:
		    \begin{itemize}
		        \item $0 \in Z$,
		        \item all elements of $Z$ are nonzero.
		    \end{itemize}		
		    In the first case, if an element of $Z$ is equal to zero then $X-1$ is a factor of $v$. Otherwise 
				\[ bz_0,bz_1,\ldots,bz_{n-1} \in \mathbb{F}^{*}_l.\]
				All the cosets of $\mathbb{F}^{*}_l$ must have $d \mid l-1$ elements but $\gcd(n,l-1)=1$ so $Z$ is not a coset of this group. As $Z$ is not a multiplicative coset, we can choose a positive integer $i<l$ so that $0< \deg(\gcd(v,v^{(i)})) <n$. Let $h$ be this common factor. We need to manipulate $h$ to recover a factor of the original polynomial $v$ so we let $h=h(y^{-1}X)$. 
				
				The rest of the algorithm works upwards to recover a factor of $g=M(\alpha)$ from the factor $h$ of $v$. Let $h'=h(X^l) $ then for any root $b$ of $h'$ there exists a unique root $c$ of $h'$ so that $\ind(b)[l^{s-2}]=\ind(c)[l^{s-1}]$. We have that $A_{z-2}$ is the minimal polynomial of an $l$th root of $\beta$ and so $\deg(\gcd( A_{z-2},h'))=\deg(h)$. Continuing through each iteration of the loop a $\deg(h)$ factor of $A_{z-i}$ is lifted to a $\deg(h)$ factor of $A_{z-i+1}$ until a factor of $g$ is found.
		\end{proof}
		
		Given a polynomial $f$ over a finite field $\Fq$ such that $f=f_1^{e_1} \cdots f_k^{e_k}$ for irreducible polynomials $f_1,\ldots,f_k$ let $\rad(f)=f_1 \cdots f_k$.
		
		\begin{thm}
		\label{LEM:coOrd}
		    Let $\Fq$ be a finite field, $f$ be a squarefree polynomial in $L_n$ over $\Fq$ for $n>1$, $l$ be a prime dividing $q-1$, $s=\nu_l(q-1)$, 
				\begin{alignat*}{3}
				    d_1 &=l^s,      \quad\quad && e_1=d_1^{-1} \pmod {(q-1)/l^s}, \\ 
				    d_2 &=(q-1)/l^s, \quad\quad && e_2=d_2^{-1} \pmod {l^s}, 
				\end{alignat*}
				\noindent and $g=f^{d_1e_1}$, $h=f^{d_2e_2}$. Then $\deg(\rad(g))>1$ or $\deg(\rad(h))>1$ and if $t$ is a nontrivial factor of $\rad(g)$ \textup{(}respectively $\rad(h)$ \textup{)} then $\gcd(t \otimes h,f)$ \textup{(}respectively $\gcd(t \otimes g,f)$ \textup{)} is a nontrivial factor of $f$. 
		\end{thm}	
		
		\begin{proof}		
		    Let $f=\prod_{i=1}^n{(X-\omega_i)}$ then 
		        \[ \rad(g)=\prod_{i=1}^{m_1}{(X-\gamma_i)} \quad\quad \rad(h)=\prod_{i=1}^{m_2}{(X-\beta_i)} \]
		    for $\gamma_1,\ldots,\gamma_{m_1}$ that have order dividing $d_1$ and $\beta_1,\ldots,\beta_{m_2}$ that have order dividing $d_2$. Note that $d_1$ and $d_2$ are coprime and for each root $\gamma$ of $g$ (respectively $h$) there exists a root $\beta$ of $h$ (respectively $g$) so that $\gamma\beta$ is a root of $f$. Hence $f$ divides $g \otimes h$. 		   
				
				If $\deg(\rad(g))=1$ and $\deg(\rad(h))=1$ then $g \otimes h$ has only one root. As the degree of $f$ is larger than one and $f$ is squarefree we cannot have $\deg(\rad(g))=1$ and $\deg(\rad(h))=1$.
		
		    Without loss of generality let $t$ be a nontrivial factor of $\rad(g)$. Let $\gamma$ be a root of $\rad(g)$ that is not a root of $t$. Then there is a root $\omega$ of $f$ such that $\omega=\gamma\beta$ for some root $\beta$ of $\rad(h)$ and this $\omega$ is not a root of $t \otimes h$. Hence $\gcd(t \otimes h,f)$ is a nontrivial factor of $f$.
		\end{proof}
		
		We now prove Theorem \ref{THM:CoDeg}.
		
		\begin{proof}
		    The algorithm FIND\_PRIME constructs a prime $l$ so that with $s=\nu_l(p-1)$ we have $X^{(p-1)/l^s} \not\in \Fp$. Let $\omega$ be an $l^s$ primitive root of unity and $\gamma$ be a $(p-1)/l^s$ primitive root of unity. Then the polynomial $f$ can be written 
				    \[ f=\prod_{i=0}^{n-1}{(X-\omega^{e_i}\gamma^{j_i})}. \]	
				The polynomial $t$ in Algorithm \ref{ALGO:CODEG} is 
				    \[ t=\prod_{i=0}^{n-1}{(X-\gamma^{j_i})}. \]
			  The polynomial $v$ in Algorithm \ref{ALGO:PRIMEPOWFAC} is 
				    \[ v=\prod_{i=0}^{n-1}{(X-\omega^{e_i})} \]
				and this polynomial is squarefree. The polynomial $h$ returned by Algorithm \ref{ALGO:PRIMEPOWFAC} is a nontrivial factor of $v$ by Lemma \ref{LEM:coOrd}. Hence $a$ is a nontrivial factor of $f$ by Lemma \ref{LEM:coOrd}.
		\end{proof}
						
		%
		%
    \subsection{Bounded Degree Polynomials}
		\label{SEC:bounded}
		%
		%
		
		The rest of this chapter regards the factorization of polynomials of bounded degree. Let $\Fq$ be a finite field, $c$ be a positive real number, and $B=\{ f\in L_n : \deg(f)<c \}$ the class of polynomials of bounded degree. In studying the FPFF it is interesting to consider the special case of factoring polynomials of this type. The following result was given in [\citenum{Ronyai89}].

    \begin{thm}
		\label{THM:GRHBOUNDED}
        Let $\Fq$ be a finite field, and $f$ be a polynomial of bounded degree over $\Fq$. Assuming GRH, we can find all roots of $f$ in polynomial time. 
    \end{thm}
		
		Although finding a deterministic polynomial time algorithm that does not rely on GRH appears to be a very hard problem in general, the problem of giving deterministic polynomial time algorithms for factoring polynomials of bounded degree may be easier. Theorem \ref{THM:boundedDeg} gives a new result in this direction. This result should be compared to the fastest general algorithm for factoring polynomials over $\Fp$ which was given in Chapter 2.
		
		The next lemma is from [\citenum{shpar}].
		
		\begin{lem}
		\label{LEM:leastPrim}
		    Let $\Fq$ be a finite field. Then a primitive root in $\Fq$ can be found in $O(q^{{1/4}+o(1)})$ operations.
		\end{lem}
		
		\begin{cor}
    \label{LEM:leastNonres}
		    Let $\Fq$ be a finite field and $l$ a prime dividing $q-1$. Then an $l$th nonresidue can be found in $O \left( q^{{1/4}+o(1)} \right)$ operations.
		\end{cor}
		
		\begin{proof}
		    By Lemma \ref{LEM:leastPrim} we can construct an $l$th primitive root $\zeta$ in $\Fq$. Hence $\zeta$ is an $r$th nonresidue for each prime $r$ dividing $q-1$. In particular, $\zeta$ is an $l$th nonresidue.
		\end{proof}
		
		\begin{thm}
		\label{THM:boundedDeg}
		    Let $\Fp$ be a finite field, and $f$ be a polynomial of bounded degree over $\Fq$. Then $f$ can be factored deterministically in $\poly \left(  p^{1/4+o(1)} \right) $ operations. 
		\end{thm}
		
		\begin{proof}
		    We proceed by induction on the least prime $l$ dividing the degree $n$ of the polynomial to be factored. Suppose we have $l=2$. Then by Corollary \ref{LEM:leastNonres} we can construct a quadratic nonresidue in $\left(p^{1/4+o(1)} \right)$ operations. Given a quadratic nonresidue we can factor $f$ deterministically in $\poly(\log(p))$ operations by Theorem \ref{THM:Ronyai}.
				
				Now let $l_1,\ldots,l_t$ be the first $t$ prime numbers and suppose we can factor any polynomial of bounded degree $m$ so that at least one of $l_1,\ldots,l_{t-1}$ divides $m$. We wish to show that this is sufficient to construct an algorithm that factors any polynomial $g$ of degree $n$ so that the least prime factor of $n$ is $l_t$. 
				
				Let $h$ be an irreducible factor of $\Phi_{l_t}$. If we can construct a field extension of the form $\Fq=\Fp[X]/(h)$ then by Theorem \ref{LEM:leastNonres} we can construct an $l$th nonresidue in $\Fq$ and then by Theorem \ref{THM:almostRonyai} a factor of $f$ can be constructed deterministically in $\poly(\log(p))$ operations. To prove the inductive step we need only show it is possible to factor $\Phi_{l_t}$. 
				
				The degree of $\Phi_{l_t}$ is $l_t-1$ so by Theorem \ref{THM:rootFinding}, finding an irreducible factor $h$ of $\Phi_{l_t}$ in $\Fp$ reduces to finding a root of a polynomial $f$ of degree at most $\deg(\Phi_{l_t})=l_t-1$ in $\Fp$. In particular, the degree is divisible by a prime less than $l_t$. So by the inductive assumption we can factor $f=f_1 f_2$ where without loss of generality $\deg(f_1)<(l-1)/2$. As the degree of $f_1$ is less than $l_t$ it factors as a product of primes less than $l_t$. Hence we can factor $f_1$. We repeat these factorizations until a root of $f$ is found. As the degree of the polynomial to be factored is halved at each step at most $\log(l_t-1)$ factorizations are needed but since $l_t$ is bounded this is simply a constant number of operations. So the total number of operations for all the factorizations is $\poly \left( p^{1/4+o(1)} \right)$ by the recursive assumption.
				
				Having found a root of $f$ we proceed with Theorem \ref{THM:rootFinding} to construct an irreducible factor of $\Phi_{l_t}$ which takes $\poly(\log(p))$ operations. We then use Theorem \ref{ALGO:NONFLAT} to factor $g$ deterministically which takes $\poly(\log(p))$ operations. The number of operations for the full algorithm is then $\poly \left(p^{1/4+o(1)} \right)$.
				
		\end{proof}
				
%
% ERH
%
\newpage		
\chapter{Results conditional on GRH}
\label{CH:ERH}
		
		%
		%
		%
		\subsection{Factoring even degree polynomials under ERH}
		%
		%
		%
    The main result of this section is Theorem \ref{THM:almostRonyai}. This result was originally proved in [\citenum{ronyai1988factoring}] and was proved by an alternate method in [\citenum{gao}]. The goal of this chapter is to give a proof of this theorem that requires less background knowledge than the previous proofs. 
			
		% now into the discussion of theorem evDeg
	  We work up to Theorem \ref{THM:almostRonyai} in steps. In Theorem \ref{THM:even} we prove that even degree polynomials with a certain property can be factored in deterministic polynomial time under GRH. In Theorem \ref{THM:even} we show that $\emph{all}$ even degree polynomials can be factored in deterministic polynomial time. These results are generalized in Theorem \ref{THM:almostRonyai}. 
		
		The high level idea for all these results is similar to that of Theorem \ref{THM:TwoOfFour}. We do a composed operation on the polynomial $f$ to get a polynomial $g$, use some structure of the resulting polynomial to do a factorization of $g$, and then ``reverse'' the composed operation and apply Algorithm \ref{ALGO:NONFLAT} to attempt to recover a factor of the original polynomial.
			
		In the case of Theorem \ref{THM:even} the composed operations is $\ominus$. This operation is reversed by $\oplus$. We begin by constructing $g=X^{-n}(f \ominus f)$. The choice of $\ominus$ as the composed operation is motivated by the following observation from Chapter \ref{CH:Background}. If $r_1,r_2$ are elements of $\Fp$ and $\ind(r_1-r_2) \equiv k \pmod {2^s}$ then $\ind(r_2-r_1) \not\equiv k \pmod {2^s}$. Hence $g$ can be factored by Algorithm \ref{ALGO:INDFAC}.
				
		Factoring $g$ is not sufficient to be able to construct a factor of $f$. We call factors of $g$ that do not permit a factor of $f$ to be recovered $\ominus$-\emph{balanced}. We give several different types of $\ominus$-balance. The simplest, used in Algorithm \ref{ALGO:INDSPLIT} is Definition \ref{DEF:DiffBalanced}. The definition of $\ominus$-balanced polynomials mirrors Definition \ref{DEF:balanced}.
		
		\begin{mydef}
		\label{DEF:DiffBalanced}
		    Let $\Fq$ be a finite field, let $f \in L_n$, let $R$ be the set of roots of $f$, and let $t_1=X^{-n}(f \ominus f)$. A factor $h$ of $t_1$ is \emph{$\ominus$-balanced} with respect to $f$ if for each root $a \in R$
			    
				\[    {\#} \{ b \in R : a \not= b \textrm{ and } h(a - b)=0 \} = \frac{n-1}{2}. \]
				 
		\end{mydef}
		
		As an example of Definition \ref{DEF:DiffBalanced} if $f=(X-(r_1-r_2))(X-(r_2-r_3))(X-(r_3-r_1))$ for some $r_1,r_2,r_3$ in a finite field $\Fq$ then $f$ is balanced. We note that every even degree polynomial is not balanced. Indeed, Algorithm \ref{ALGO:even} can factor any even degree polynomial deterministically in polynomial time under GRH.
		
		Next we define $l$-index decompositions and $(l,k)$-index partitions which are used throughout this chapter. We give an example to motivate Definition \ref{DEF:IndexDecomposition}. Recall the example we gave in Chapter \ref{CH:Background} of factoring a polynomial using Algorithm \ref{ALGO:INDFAC}. In this example we took $p$ to be a prime so that $s=\nu_2(p-1)=4$, and $z$ be a quadratic nonresidue modulo $p$. We let $a$ and $b$ be distinct elements of $\Fp$ of odd order, and let
		
	  \[ f=(X-az)(X-bz)(X-az^3)(X-bz^3)(X-az^{13})(X-bz^{13}). \]

		We found the factorization $f=g_1 g_2 h_2$ with
		\[ 
		    g_1=(X-az)(X-bz) \quad\quad
				g_2=(X-az^{13})(X-bz^{13}) \quad\quad
				h_2=(X-az^3)(X-bz^3).
		\]
		
		This is as far as we could take factorization $f$ using Algorithm \ref{ALGO:INDFAC}. In particular we observed that if $a$ and $b$ are arbitrary roots of distinct elements of the set $\{ g_1,g_2,h_2 \}$ then $\ind(a) \not\equiv \ind(b) \pmod{2^s}.$ 
		
		% point of twoIndex decomposition is that any pair of linear factors dividing any elem in the set have the same index
		\begin{mydef}
		\label{DEF:IndexDecomposition}
		    Let $\Fq$ be a finite field, $l$ a prime diving $q-1$, $s=\nu_l(q-1)$, and $f \in L_n$. Then a set of polynomials $T$ is an \emph{$l$-index decomposition} of $f$ if $f=\prod_{t \in T}{t}$ and for all $t \in T$ and for all pairs $z_1,z_2 \in \Fq$ such that $(X-z_1) \mid t$ and $(X-z_2) \mid t$ we have $\ind(X-z_1) \equiv \ind(X-z_2) \pmod {l^s}$. 
		\end{mydef}
		
		The set $\{g_1,g_2,h_2 \}$ given before the example is an $2$-index decomposition of the polynomial $f$.
		
		Algorithm \ref{ALGO:DECOMP} shows how to construct an $l$-index decomposition. Algorithm \ref{ALGO:INDSPLIT} is an auxiliary algorithm for Algorithm \ref{ALGO:DECOMP} that takes a prime $l$ and a list of polynomials and calls Algorithm \ref{ALGO:INDFAC} on each polynomial in the tuple. Algorithm \ref{ALGO:INDSPLIT} makes use of the following algorithms:
		\begin{itemize}
		    \item IND\_FAC - Algorithm \ref{ALGO:INDFAC}. 
		\end{itemize}
		
		% \textup is the explicit command for "upright"
		% DEPENDS ON IND
		\begin{singlespace}
    \begin{algorithm}[H]
		\DontPrintSemicolon
		\label{ALGO:INDSPLIT}
		    \caption{SPLIT} 
		    Input : $\Fq,l,k,A,\zeta$ \;
		      \hspace{2mm} $\Fq$ a finite field \;
				  \hspace{2mm} $l$ a prime dividing $q-1$ such that $s=\nu_l(q-1)$ \;
		      \hspace{2mm} $k$ a nonnegative integer so that $k < s$ \;
				  % have to do this so that g_i does not know about 
		      \hspace{2mm} $A$ a set of $m$ polynomials $g_1,\ldots,g_m$ such that $g_i$ is a product of linear factors and for every \;
					\hspace{2mm} $g_i,g_j \in A$ we have $\ind(g_i)[l^t] \not=\ind(g_j)[l^t]$ for $k<t\leq s-1$ \;
					\hspace{2mm} $\zeta$ an $l$th nonresidue \;
		    Output : $A_2$ a set of $m_2$ polynomials $h_1,\ldots,h_{m_2}$ such that $h_i$ is a product of linear factors and for every $h_i,h_j \in A_2$ we have $\ind(h_i)[l^t] \not=\ind(h_j)[l^t]$ for $k+1<t\leq s-1$ \;
		    \;
				
		    Initialize $A_2$ as an empty list \;
		    \For{$a \in A$}{
				    % WARNING
						% 
						% TO DO find out what the inputs into IND are and make sure they are in the right order
		        $a_1=\rm{IND\_FAC}(\Fq,l,\zeta,a)$ \;
				    $a_2=a/{a_1}$ \;
				    \If{$0 < \deg(a_1) \textup{\textbf{ and }} \deg(a_1) < \deg(a)$}{
				       Add $a_1$ and $a_2$ to $A_2$ \;
				    }
						\Else{
				       Add $a$ to $A_2$ \;				
						}
		    }
				Return $A_2$		
    \end{algorithm}
		\end{singlespace}
	  \vspace{5mm}		
		
		Algorithm \ref{ALGO:DECOMP} constructs an $l$-index decomposition by repeatedly calling Algorithm \ref{ALGO:INDSPLIT}. Algorithm \ref{ALGO:DECOMP} makes use of the following algorithms: 
		\begin{itemize}
		\item IS\_SQF                                         
		\item SQRFREE\_DECOMP - Algorithm \ref{ALGO:SQFDECOMP} 
		\item SPLIT - Algorithm \ref{ALGO:INDSPLIT}            
		\end{itemize}
				
		% DEPENDS ON THE SPLITTING ALGO	
		\begin{singlespace}
    \begin{algorithm}[H]
		\DontPrintSemicolon
		    \label{ALGO:DECOMP}
		    \caption{DECOMP} 
		    Input : $\Fq,l,f$ \;
				  \hspace{2mm} $\Fq$ a finite field \;
					\hspace{2mm} $l$ a prime dividing $q-1$ \;
				  \hspace{2mm} $f \in L_n$ for some positive integer $n$ \;
		    Output : $l$-index decomposition of $f$ \;	
				\;
				Construct an $l$th nonresidue $\zeta$ in $\Fq$ using Theorem \ref{THM:Huang} \;
				\tcc{The algorithm is simpler when the polynomial is squarefree so we split the algorithm into two cases}
				\If{$ \textrm{IS\_SQF}(f)=true $}{
		        $s=\nu_l(q-1)$ \;
		        $D=[f]$ \;
		        \For{$i=0 \textup{\textbf{ to }} s-1$}{
						    \tcc{$D$ is a tuple of $k$ elements $d_1,\ldots,d_k$}
								Initialize $B$ as an empty tuple \;
								\For{$j=1 \textup{\textbf{ to }} k$}{
										$B=B \cup \textrm{SPLIT}(\Fq, l, d_{j},\zeta)$ \;
							  }
								$D=B$ \;
		        }
						Return $A$ \;
			  }
		    % this algorithm unfortunatly has to be general, f cant be assumed to be squarefree
        \Else{
				    \tcc{$A=\{a_1,\ldots,a_m \}$ is a squarefree decomposition of $f=g_1^{e_1}\cdots g_k^{e_k}$ with $e_1<e_2<\cdots<e_k$}
						\tcc{$a_i$ is a pair $[g_k,e_k]$} 
						Let $a_{i,0}$ be the first element of $a_i$ \;
            $A = \textrm{SQRFREE\_DECOMP}(f,\Fq)$ \;
						$m=\#A$ \;
            \tcc{Initialize $d$ as an empty tuple $d=[d_1,\ldots,d_{m}]$}  
						\tcc{$d_i$ will hold a tuple of polynomials}
            \For{$i \textup{\textbf{ to }} m$}{           
                \tcc{Recursive call of DECOMP for each element in the squarefree decomposition}  
								Let $d_{i,j}$ be the $j$th element of $d_i$ \;
								\tcc{The recursive call enters the squarefree case}
                $d_i = \textrm{DECOMP}(\Fq, l, a_{i,0},\zeta)$    \;       
                \For{$j \textup{\textbf{ from }} 1 \textup{\textbf{ to }} \# d_i$}{
                    $d_{i,j}=(d_{i,j})^i$ \;
                }
            }
            Return $d$ \;
				}
    \end{algorithm}
		\end{singlespace}
		\vspace{5mm}
				
		For example, let $p$ be a prime, $f$ be a squarefree polynomial in $\Fp[X]$ such that $f=(X-r_1)(X+r_1)(X-r_2)(X+r_2)$ and let $s=\nu_2(p-1)=1$ then we have $\ind(-r_1)[2^{s-1}] \in \{0,1\}$ and $\ind(-r_1)[2^{s-1}] \not= \ind(r_1)[2^{s-1}]$. We apply Algorithm \ref{ALGO:DECOMP} to $f$ which gives $D=[f]$. After SPLIT is applied to $A$ we have $D=[(X-r_1)(X-r_2),(X+r_1)(X+r_2)]$. The algorithm returns this $D$. If instead we had $s=\nu_2(p-1)=2$ then SPLIT would be applied to each of the polynomials $(X-r_1)(X-r_2),(X+r_1)(X+r_2)$.
						
		\begin{thm}
		\label{THM:DECOMP}
		    Let $\Fq$ be a finite field, $l$ a prime dividing $q-1$. Then Algorithm \ref{ALGO:DECOMP} constructs an $l$-index decomposition in deterministic $\poly(\log(q),n,l)$ operations under GRH.
		\end{thm}
		
		\begin{proof}
		    First we consider the squarefree case. The number of elements in $A$ is never more than $n$. Each recursive call to Algorithm \ref{ALGO:INDSPLIT} consists of at most $n$ calls to Algorithm \ref{ALGO:INDFAC} plus some simple algebraic manipulations. By Theorem \ref{THM:vonzurGathen} the call to Algorithm \ref{ALGO:INDFAC} can be done within the given number of operations. By Theorem \ref{THM:runTimes} the other operations can be done within the given number of operations. The non-squarefree case consists of iterating over a tuple of at most $n$ elements and making a call to DECOMP with a squarefree polynomial for each element in the tuple and raising an element to a power. This exponentiation can be done in the time bound by Theorem \ref{THM:runTimes}. 
		\end{proof}
							
		\begin{mydef}
		\label{DEF:IndexPartition}
		    Let $\Fq$ be a finite field, $f$ a polynomial in $L_n$, $l$ be a prime dividing $q-1$, and $k$ be a nonnegative integer less than $\nu_l(q-1)$. A set of $l$ polynomials $M=\{m_0,\ldots,m_{l-1} \}$ over $\Fq$ is an \emph{$(l,k)$-index partition} if $f=\prod_{j=0}^{l-1}{m_j}$ and $\ind(m_j)[l^k]=j$. 
		\end{mydef}
		
		We give an example of constructing a (2,2) index partion of a polynomial $f$. This example follows the example used for Definition \ref{DEF:IndexDecomposition}. We take $p$ a prime, $s=v_2(p-1)=4$, $z$ a quadratic nonresidue, and $a, b$ elements of odd order, and 
		\[ f=(X-az)(X-bz)(X-az^3)(X-bz^3)(X-az^{13})(X-bz^{13}).\] Let $l=2$, $k=3$, and $A=[f]$. As $k=s-1$ there are no integers $t$ so that $k<t\leq s-1$ so the condition on $A$ is met. We construct the quadratic nonresidue $\zeta$ modulo $p$. The roots of the polynomial $f$ are roots $az,-bz,-az^3,-bz^3,-az^{13},-bz^{13}$. In Chapter 2 we saw that the base 2 representations of the indexes are $[1,1,11,11,1101,1101]$. Hence the set of polynomials 
		\[ \{ (X-az)(X-bz)(X-az^3)(X-bz^3),(X-az^{13})(X-bz^{13}) \}\]
		\noindent is a $(2,2)$-index partition of the polynomial $f$.
		
		Algorithm \ref{ALGO:PART} gives the pseudocode for partitioning a polynomial based on its $2$-index. The algorithm for general $l \mid q-1$ is similar but more involved.

		\begin{singlespace}
    \begin{algorithm}[H]
		\DontPrintSemicolon
		    \label{ALGO:PART}
		    \caption{PARTITION} 
				% could also be called LAST BIT PARTITION
		    Input : $\Fq, f, M$ \;
				\hspace{2mm} $\Fq$ a finite field \;
				\hspace{2mm} $M$ is a 2-index decomposition of $f$  \;
        Output : A $(2,s-1)$-index partition of $f$ \;
        $n=\#M$ \;
        $L_0 = 1$ \;
        $L_1 = 1$ \;
        $s=\nu_2(q-1)$ \;
				$R=\Fq[X]/(f)$ \;
        \For{$i$ \textup{\textbf{from}} 1 \textup{\textbf{to}} $n$}{
            $f=M[i]$ \;
						\tcc{$t$ is an element in the ring $R$} 
            $t=X^{(q-1)/{2^s}} $\;
            \If{$\deg(t,X)>0$}{
                Return FAIL \;        
            }
						% in my code I have a method lastBit that does the following \;
            \If{$ \ind(t)[2^{s-1}] = 0$}{
                $L_0=f \cdot L_0$ \;
			      }
            \ElseIf{$ \ind(t)[2^{s-1}] = 1$}{
                $L_1=f \cdot L_1$ \;  
				    }
            \Else{
                Return FAIL;
            }
		    }
        Return $[L_0, L_1]$ \;
    \end{algorithm}
		\end{singlespace}		
		\vspace{5mm}		
		
		\begin{thm}
		\label{THM:PART}
		    Let $\Fq$ be a finite field, $f$ a polynomial in $L_n$, $l$ be a prime dividing $q-1$, and $k$ be a nonnegative integer less than $\nu_l(q-1)$. Then there exists an algorithm, of which Algorithm \ref{ALGO:PART} is a special case, that constructs an $(l,k)$-index partition of $f$ in $\poly(\log(q),n,l)$ operations.
		\end{thm}
								
		% I think cycle is a good word b/c it associates the poly with something visual
		The next lemma is an application of Algorithm \ref{ALGO:PART}. A polynomial $f \in L_n$ such that $f=g(X^m)$ for some polynomial $g \in L_{n/m}$ and positive integer $m$ is called an \emph{$m$-cycle polynomial}.
						
		\begin{thm} 
		\label{THM:mCycle} 
		    Let $f \in L_n$ be a $m$-cycle polynomial over $\Fq$. If an $m$th nonresidue in $\Fq$ is given then $f$ can be factored as $f_1 \cdots f_m$ such that the polynomials $f_i$ have the same degree and are pairwise relatively prime.  
		\end{thm}
				
	  \begin{proof}
	      Let $g$ be the polynomial such that $f=g(X^m)$ and let $s=\nu_m(q-1)$. If $\zeta$ is a root of $g$	then all the roots of the polynomial $X^m-\zeta$ are roots of $f$. If $\alpha$ is a root of $X^m-\zeta$ and $\omega$ is an primitive $m$th root of unity then $\zeta,\zeta\omega,\ldots, \zeta\omega^{m-1}$ are all the roots of $X^m-\zeta$. The indexes of this set are $\ind(\zeta\omega^{i})=\ind(\zeta)+\ind(\omega^i)=\ind(\zeta)+i \cdot \ind(\omega)$ hence $\ind(\zeta\omega^{i})  \equiv \ind(\zeta) + im^{s-1} \pmod{m^s}$. This equality shows that the $(m,s-1)$ index partition consists of the following $r$ polynomials $t_0,\ldots,t_{r-1}$ of degree $n/m$ with		
				\[   t_i = \prod_{\ind(r)[m^{s-1}]=i}{(X-r)}.   \]
		\end{proof}
		
		This theorem is given in [\citenum{ronyai1988factoring}] as Proposition 2.3. (This proposition calls $f$ for which $f=g(X^r)$ \emph{r-good} polynomials. Although Proposition 2.3 regards \emph{$r$-good} polynomials with an additional property, all $r$-good polynomials turn out to have this property). 
		% Theorem \ref{rCycle} is also implicit in [\citenum{von1987factoring}]. 
						
		%
				
		We now give an algorithm for factoring polynomials of even degree. Let $f$ be a polynomial of degree $n$ in $L_n$. The algorithm is based on the following idea. Let $r_i$, and $r_j$ be roots of $f$. If $\ind(r_i-r_j) \equiv k \pmod {2^s}$ then as we saw in an example in Chapter \ref{CH:Background}, $\ind(r_j-r_i) \not\equiv k \pmod {2^s}$. Hence Algorithm \ref{ALGO:TWOIND} produces a factor of $h=X^{-n}(f \ominus f)$. We apply Algorithm \ref{ALGO:NONFLAT} to $h$ to recover a factor of the original polynomial $f$.\hspace*{\fill}
			
		Algorithm \ref{ALGO:even} makes use of the following algorithms:
		\begin{itemize}
		\item IS\_SQF                                    
		\item DECOMP - Algorithm \ref{ALGO:DECOMP}       
    \item PARTITION - Algorithm \ref{ALGO:PART}      
		\item BASE - Given a polynomial $f$ with factorization $f_1^{e_1} \cdots  f_k^{e_k}$ over $\Fq$ $\textrm{BASE}(f)=f_1 \cdots f_k$                               
		\item NON\_FLAT - Algorithm \ref{ALGO:NONFLAT}
		\end{itemize}
		
		\begin{singlespace}
    \begin{algorithm}[H]
		\DontPrintSemicolon
		\label{ALGO:even}	
		\caption{EVEN\_DEG}
		    Input : $\Fq,f$ \;
				\hspace{2mm} $\Fq$ a finite field \;
				\hspace{2mm} $f$ in $L_n$, $f$ squarefree, and $n$ even \;
        $s = \nu_2(q-1)$ \;
        $h = X^{-n}(f \ominus f)$ \;  
        $d = \textrm{DECOMP}(\Fq,2,f)$ \;
        \tcc{$t$ is a pair of polynomials $t_1,t_2$ of degree $n(n-1)/2$}
				$t = \textrm{PARTITION}(\Fq,d)$ \;
        $T = \textrm{BASE}(t)$ \;
        $g = T \oplus f$ \;
        Return $\textrm{NON\_FLAT}(\Fq,f,g)$ \;
    \end{algorithm}
		\end{singlespace}		
		\vspace{5mm}		
		
		As in Chapter \ref{CH:uncond}, it may be useful to interpret the steps of Algorithm \ref{ALGO:even} in terms of graphs. In Definition \ref{DEF:arcpoly} we defined arc polynomials. Given a polynomial $f$ on $n$ vertices $r_1,\ldots,r_n$ then the arc polynomial corresponding to $h=X^{-n}(f \ominus f)$ is the complete directed graph. 
		
		Now suppose, for example, we are given a prime $p \equiv 3 \pmod 4$. We apply Algorithm \ref{ALGO:TWOIND} to this polynomial which gives a factor $t_0$ of $h$ with $\deg(t_0)=n(n-1)/2$ of $h$ because for any pair of roots $r_1,r_2$ exactly one of $\{ r_1-r_2, r_2-r_1 \}$ is a quadratic nonresidue. In the corresponding arc polynomial exactly one of the arcs $\{ [r_1,r_2], [r_2,r_1] \}$ appears. Hence the graph represented by the arc polynomial $t_0$ is a tournament.
		
		For example, let $p=103$ and let $\chi(a)=a^{(p-1)/2}$ for $a \in \Fp$. Let $r_1 = 5, r_2 = 17, r_3 = 23, r_4 = 101$, and
		\begin{alignat*}{5}
		v_1    &= \chi(r_1-r_2) &&=1  \quad\quad && v_2    &&= \chi(r_2-r_1)  &&=-1, \\
    v_3    &= \chi(r_1-r_3) &&=-1 \quad\quad && v_4    &&= \chi(r_3-r_1)  &&=1,  \\
    v_5    &= \chi(r_1-r_4) &&=1  \quad\quad && v_6    &&= \chi(r_4-r_1)  &&=-1, \\
    v_7    &= \chi(r_2-r_3) &&=1  \quad\quad && v_8    &&= \chi(r_3-r_2)  &&=-1, \\
    v_9    &= \chi(r_2-r_4) &&=1  \quad\quad && v_{10} &&= \chi(r_4-r_2)  &&=-1, \\
    v_{11} &= \chi(r_3-r_4) &&=1  \quad\quad && v_{12} &&= \chi(r_4-r_3)  &&=-1. \\
		\end{alignat*}
		As a result, the polynomial $t_0$ that we recover is 
		\[ \bigl(X-(r_1-r_2) \bigr)\bigl(X-(r_3-r_1)\bigr)\bigl(X-(r_1-r_4)\bigr)\bigl(X-(r_2-r_3)\bigr)\bigl(X-(r_2-r_4)\bigr)\bigl(X-(r_3-r_4)\bigr).\]
		The corresponding tournament is shown in Figure \ref{FIG:polyTourn}. In this figure the vertices $1,2,3,4$ correspond to the roots $r_1,r_2,r_3,r_4$. The edges correspond to the arc polynomial $t_0$.
		
		\begin{center}
		    \begin{figure}
				\label{FIG:polyTourn}
				\input{C:/ttex/sep19.txt} 
				\caption{A tournament on four vertices} 
				\end{figure}
		\end{center}
		
		\begin{mydef}
		\label{DEF:score}
		    Let $\Fq$ be a finite field, $s=\nu_2(q-1)$, $f \in L_n$ over $\Fq$ with roots $R=\{r_1,\ldots,r_n \}$, and $h=X^{-n}(f \ominus f)$ with roots $H$. The 2-\emph{score} $S(r)$ of $r \in R$ is the number of elements $r_i-r_j$ of $H$ such that $\ind(r_i-r_j)[2^{s-1}]=0$. The \emph{score polynomial} $L$ is defined $L=\prod_{i=1}^n{(X-r_i)^{S(r_i)}}.$
		\end{mydef}
		
		\begin{thm} 
		\label{THM:even}
		    Let $\Fq$ be a finite field, and $f$ be a polynomial in $L_n$ of even degree. Under ERH Algorithm \ref{ALGO:even} factors $f$ deterministically in $\poly(n,\log(q))$ $\Fp$-operations.
		\end{thm}
		
		\begin{proof}
		    If $n>p$ we can factor $f$ in deterministic polynomial time using Theorem \ref{THM:berleFac}. If $n<p$ construct the polynomial $h=X^{-n}(f \ominus f)$. The polynomial $h$ is a 2-cycle polynomial and so if $R$ denotes the set of roots of $f$ then half the elements $r \in R$ are such that $\ind(r)[2^{s-1}]=0$ and the other half $\ind(r)[2^{s-1}]=1$. Let $T$ be the factor of $h$ whose roots are $\{a_i : h(a_i)=0 \textrm{ and } \ind(a_i)[2^{s-1}]=1  \}$. Due to the assumption of ERH we can construct a quadratic nonresidue in deterministic polynomial time. Given this quadratic nonresidue the polynomial $T$ can be constructed by Algorithm \ref{ALGO:PART}.

				Let $g=T \oplus f$. The score polynomial $L$ is a divisor of $g$. The roots of $h$ have the form $x-y$ for some roots $x,y$ of $f$ which are not equal. So the roots of $g$ have the form $x-y+z$. Clearly if $y=z$ then $x-y+z=x$. We want to show that none of the roots of $g/L$ are also roots of $f$. This is equivalent to showing that the multiplicity of the factor $(X-r)$ of $g$ is equal to the score of $r$. Let $(X-r)$ be a factor of $g$ with multiplicity $k$. Then there are $k$ solutions $x,y,z \in R$ such that $x-y$ is a root of $t$ to 
		    \begin{alignat*}{2}
		        r   &=x-y+z \\
				    r-z &= x-y.
	      \end{alignat*}
		    Hence the multiplicity of $(X-r)$ is the number of pairs of distinct elements $x,y \in R$ such that $x-y$ is a root of $t$ and is equal to $r-z$ for some $z$ in $R$. Hence the multiplicity of $(X-r)$ is equal to the score of $r$.  
				
				The score polynomial $L$ can be computed as $L=\gcd(f^{n-1},g)$. As $n$ is even, $n$ does not divide $n(n-1)/2$ so there are at least two distinct scores. Hence $L$ is not flat with respect to $f$ so by applying Algorithm \ref{ALGO:NONFLAT} we can recover a factor. 
		\end{proof}
			
	  %
		%
		%
		\subsection{Factoring generic polynomials under GRH}
		%
		%
		%
		We now discuss how to generalize Theorem \ref{THM:even} result to arbitrary polynomials. The following lemma is needed for the proof of Theorem \ref{THM:almostRonyai}. 
		
		\begin{lem}
		\label{LEM:cycle}
		    Let $\Fq$ be a finite field, $f \in L_n$, $\omega$ be a primitive $l$th root of unity, and let $g_i=\omega^i f$ for $i=0,\ldots,l-1$
		    \[
		        \prod_{i=0}^{l-1}{(X-g_i)}=X^l-f^l.
		    \]
	  \end{lem}
		
		\begin{proof}
		    As we saw in Chapter 2 $X^d-1$ is a product of all the elements of order $d$ in $\Fq$. Hence the roots of $f^{-l}(X^l-f^l)=(X/f)^l-1$ is the set of $d$th roots of unity in $\Fq$. The result follows. 
		\end{proof}
		
		The next definition generalizes Definition \ref{DEF:DiffBalanced}.
		
		\begin{mydef}
		\label{DEF:RonyaiBalanced}
		    Let $l$ be a prime and $\Fq$ be a finite field so that $q \equiv 1 \pmod l$. Let $f=(X-r_1)\cdots(X-r_n)$ for $r_i \in \Fq$. A polynomial $h$ of degree 
				\[ \frac{n(n-1)(n-2)\cdots(n-l+1)}{l} \]
				is $(\ominus,l)$-\emph{balanced} with respect to $f$ if for each root $\lambda$ of $f$  
			  \[ {\#} \{ r_{k_0},\ldots,r_{k_{l-2}} \in R : h(r_{k_0}+\omega r_{k_1} + \ldots + \omega^{l-2} r_{k_{l-2}} + \omega^{l-1}{\lambda}  )=0 \} = \frac{(n-1)(n-2)\cdots(n-l+1)}{l}. \]
		\end{mydef}
		
		If $l$ is a prime factor of $n$ then $h$ is not $(\ominus,l)$-balanced with respect to $f$. 
		
		We now discuss how to generalize Theorem \ref{THM:even} result to arbitrary polynomials. Let 
		\[ f=\prod_{i=1}^n{(X-r_i)} \]
		be a degree $n$ polynomial over $\Fp$. Let $l$ be the least prime factor of $n$. Under GRH by Theorem \ref{THM:Huang} we can construct an extension $\Fq$ of $\Fp$ that contains primitive $l$th primitive roots of unity. Let $Y_1,\ldots,Y_n$ be indeterminants and $G$ be the set of permutations of subsets of $l$ elements of $[Y_1,\ldots,Y_n]$. Every element in $G$ has the form $[Y_{i_1},\ldots,Y_{i_l}]$ such that $1 \leq i_k \leq n$ and all the $i_k$ are distinct, and let $R=\Fq[Y_1,\ldots,Y_n]$. We define the linear map $\sigma : R \rightarrow \Fq$
		\[
		    \sigma(g)
				=\sigma([Y_{i_1},\ldots,Y_{i_r}])
				=[r_{i_1} , \ldots, r_{i_r} ].
		\]
		\noindent for any $g$ in $G$.
		
		Let $\omega$ be an $l$th primitive root of unity in $\Fq$. We define a linear polynomial in $R$ on the elements of $G$
		\[
		    L(g)=L([Y_{i_0},\ldots,Y_{i_{l-1}}])=\sum_{k=0}^{l-1}{\omega^kY_{i_k}}.
		\]
		for any $g \in G$. When $l=n$ this polynomial is sometimes referred to as the \emph{Lagrange resolvent}. It appears in Galois theory, for example in the derivation of Cardano's formula for expressing the roots of a cubic polynomial in terms of radicals. For general $l$ we will call it the \emph{resolvent polynomial} of $g$.

    Now we define a polynomial over $\Fq[X]$ which has $\sigma(L(g))$ for each $g \in G$ as its roots. Let 
		\[
		    t_G = \prod_{g \in G}{\Bigl(X-\sigma \bigl(L(g) \bigr) \Bigr)}.
		\]
		
		Let $S$ be the a subset of $G$ of $ \#G/n$ elements such that no elements of $S$ are in the same $r$-cycle. By Lemma \ref{LEM:cycle} we can regroup the terms of $t(G)$ as

    \begin{equation}
		\label{EQ:tG}
        t_G=\prod_{s \in S}{\Bigl(X^l-\sigma \bigl(L(s) \bigr)^l \Bigr)}.
    \end{equation}

    Hence $t_G$ is a $l$-cycle polynomial.
		
	  Our goal is to construct the polynomial $t_G$. We have already seen how to construct $t_G$ in the case $l=2$ using the composed difference of $f \ominus f$. In order to construct this polynomial we continue use the composed sum of a set of polynomial whose roots are related to $f$ by a multiplicative factor. However, using the composed sum in this way generates some factors that are not factors of $t_G$. These factors must then be divided out. For example, if $\Fq$ is a finite field and we are given the three polynomials 
		\begin{alignat*}{2}
		    &f_0=(X-\lambda_0 r_1)(X-\lambda_0 r_2)(X-\lambda_0 r_3) \\
				&f_1=(X-\lambda_1 r_1)(X-\lambda_1 r_2)(X-\lambda_1 r_3) \\
				&f_2=(X-\lambda_2 r_1)(X-\lambda_2 r_2)(X-\lambda_2 r_3) 
		\end{alignat*}
		\noindent with $r_1,\ldots,r_n \in \Fq$ and $a,b \in \Fq$ and we let $g=f_1 \oplus f_2 \oplus f_3$ and 
		\begin{alignat*}{2}
		    v_1 &= \lambda_0 r_1+\lambda_1 r_2+\lambda_2 r_3 \\
				v_2 &= \lambda_0 r_1+\lambda_1 r_3+\lambda_2 r_2 \\
				v_3 &= \lambda_0 r_2+\lambda_1 r_1+\lambda_2 r_3 \\
				v_4 &= \lambda_0 r_2+\lambda_1 r_3+\lambda_2 r_1 \\
				v_5 &= \lambda_0 r_3+\lambda_1 r_1+\lambda_2 r_2 \\
				v_6 &= \lambda_0 r_3+\lambda_1 r_2+\lambda_2 r_1 
		\end{alignat*}
		\[ h=(X-v_1)(X-v_2)(X-v_3)(X-v_4)(X-v_5)(X-v_6) \]
		\noindent then $h \mid g$. If we take $\lambda_i=\omega^i$ with $\omega$ a primitive 3rd root of unity then $h=t_G$. Hence we can construct $t_G$ by first finding $g$ and then removing the 21 roots of $g$ that are not roots of $h$. We now define the type of factors that we must remove from $g$. 
		
		\begin{mydef}
		\label{DEF:ComPair}
		    Let $\Fq$ be a finite field and $f$ be a polynomial with roots $\{r_1,\ldots, r_{n} \}$ over $\Fq$ and let $l$ be a prime dividing $q-1$ and dividing $l$. Then $h$ is a $i$-\emph{common pair} polynomial for $0 \leq i \leq l$ if its roots have the form $r_{j_0} + \omega r_{j_1} + \cdots + \omega^{i-1}r_{j_{i-1}} + \omega^{i}r_{j_{k}}$ where $r_{j_0}, r_{j_1}, r_{j_{i-1}}, r_{j_{k}}$ are all distinct and $r_{j_{k}}=r$ for some $r \in \{ r_{j_0}, r_{j_1},\ldots, r_{j_{i-1}} \}$. 
		\end{mydef}
		
		For example let $\Fq$ be a finite field with 3rd primitive roots of unity $\omega$. Then 
		\begin{alignat*}{2}
		f=&(X-(r_1+\omega r_2 + \omega^2 r_2))(X-(r_2+\omega r_1 + \omega^2 r_1))(X-(r_2+\omega r_3 + \omega^2 r_3)) \\
		  & \cdot(X-(r_3+\omega r_2 + \omega^2 r_2))(X-(r_1+\omega r_3 + \omega^2 r_3))(X-(r_3+\omega r_1 + \omega^2 r_1)) 
		\end{alignat*}
		is a 2-common pair polynomial. Algorithm \ref{ALGO:COMPAIR} takes a polynomial $f$ as input and returns a list of common pair polynomials $h_0,\ldots,h_i$ for some integer $i$.
    \begin{singlespace}
    \begin{algorithm}[H]
		\DontPrintSemicolon
    \label{ALGO:COMPAIR}
    \caption{COM\_PAIR}
        Input : $\Fq,f,\omega,i$ \;
				\hspace{2mm} $\Fq$ a finite field \;
				\hspace{2mm} $f$ a polynomial in $L_n$ \;
				\hspace{2mm} $\omega$ a root of unity \;
				\hspace{2mm} $i$ a positive integer \;
		    Output : a list of common-pair polynomials \;
        $n=\deg(f)$ \;
        \tcc{Initialize $P$ as a list of length $i$ with elements $p_1,\ldots,p_i$}
        \For{$k \textup{\textbf{ from }} 1 \textup{\textbf{ to }} i$}{
            \If{ ${\omega}^i+{\omega}^{k-1} \not= 0$}{
                $p_k=f(X / ({\omega}^{i}+{\omega}^{k-1}) )$ \;
            }
				    \Else{
                $p_k=X^n$ \;
            }
            $p_k=p_k \oplus \sum_{t \not= k}{\oplus f(X/{\omega}^{t-1} )}$;    
        }
        Return $P$ \;
    \end{algorithm}
    \end{singlespace} 
		\vspace{5mm}	
		
		\begin{thm}
		\label{THM:COMPAIR}
		    Let $p$ be a prime, $\Fp$ a finite field, $f$ a polynomial in $L_n$, $\omega$ a root of unity, $i$ a positive integer. Algorithm \ref{ALGO:COMPAIR} returns a list of all the $i$-common pair polynomials deterministically in $\poly(n,\log(p))$ operations.
		\end{thm}
		
		\begin{proof}
		    The elements of $p_k$ are constructed in two steps. First for each pair $i,k$ a polynomial with roots $({\omega}^{i}+{\omega}^{k-1})r_j$ for each root $r_j$ of $f$ is constructed. Then composed sum of this polynomial is computed with the polynomials $f(X/{\omega}^{t-1} )$ (each root of which is $\omega^{t-1}$ multiplied by some root of $f$). The run time follows by the fact that composed sums $f \oplus g$ can be computed in deterministic polynomial time in $\deg(f)$ and $\deg(g)$. 
		\end{proof}
			
		Algorithm \ref{ALGO:RESPOLY} constructs the polynomial $t_G$ defined earlier. Algorithm \ref{ALGO:RESPOLY} makes use of the following algorithms: 
		\begin{itemize}
    \item COM\_PAIR - Algorithm \ref{ALGO:COMPAIR} 
		\end{itemize}
		
		\begin{singlespace}
    \begin{algorithm}[H]
		\DontPrintSemicolon
    \label{ALGO:RESPOLY}	
    \caption{RESOLVENT\_POLY}
        Input : $\Fq,l,f,\omega$ \;
				\hspace{2mm} $\Fq$ a finite field \;
				\hspace{2mm} $l$ a prime dividing $q-1$ \;
				\hspace{2mm} $f$ a squarefree polynomial in $L_n$ so that $\deg(f) < n^l$ \;
				\hspace{2mm} $\omega$ an primitive $l$th root of unity in $\Fq$ \;
		    Output : a factor $h$ of $f$ \;
				\;
        \tcc{Builds up a set of ``partial polynomials''}   
		    Find $\omega$ an $l$th primitive root of unity \;
				\tcc{$H$, and $h$ hold a partial sum of the terms of the resolvent polynomial; $H$ holds the current partial sum, $h$ holds the next partial sum} 
        $H =1$ \;
        $h=f$ \;
		    Initialize $E$ as $[E_0,\ldots,E_{l-1}]$ \;
        $E=[f(X/ \omega^0),\ldots,f(X/ \omega^{l-1})]$ \;  
        \For{$i \textup{\textbf{ from }} 1 \textup{\textbf{ to }} l$}{
						Initialize $S$ as $[S_0,\ldots,S_{i}]$ \;
            $S=\textrm{COM\_PAIR}(f,\omega,i,p)$ \;
            $H=h$ \;
            $h=h \oplus E_i$ \;      
            \For{$ j \textup{\textbf{ from }} 1 \textup{\textbf{ to }} \#S $}{ 
                $g = \gcd(h,S_j)$ \;   
                $h = h/g$ \;           
            }
        }
		    Return $[H,h]$ \;
    \end{algorithm}
    \end{singlespace} 
		\vspace{5mm}
			
		Given a polynomial $f$ with roots $r_1,\ldots, r_i$ and the algorithm creates a polynomial $h$ over $\Fq$ with roots of the form $r_1+\omega r_2 + \cdots + \omega^{i} r_i$ for each subset $r_1,\ldots,r_i$ of distinct roots of $f$. The tuple $E=[f(X/ \omega^0),\ldots,f(X/ \omega^{n-1})]$ holds polynomials with roots that are multiples of $\omega^i$ of roots of the polynomial $f$. Computing the composed sum of $h$ and $E_i$ gives a polynomial with roots of the form $r_1+\omega r_2 + \cdots + \omega^{i} r_i + \omega^{i+1} \alpha$ for each subset $r_1,\ldots,r_i$ of roots of $f$ and $\alpha$ a root of $f$. We define $h$ as this composed sum. 
		
		We need to eliminate those factors of $h$ so that $\alpha$ is equal to one of the roots $r_1,\ldots,r_i$. The set of these bad factors is precisely the set of $i$-common pair polynomials. Dividing these out of $h$ gives a polynomial with roots of the form $r_1+\omega r_2 + \cdots + \omega^{i} r_i$ for each subset $r_1,\ldots,r_{i+1}$. Continuing in this way we construct the resolvent polynomial.
				
		\begin{thm}
		    Let $\Fq$ a finite field, $l$ a prime dividing $q-1$, $f$ a squarefree polynomial in $L_n$ so that $\deg(f) < n^l$, $\omega$ an primitive $l$th root of unity in $\Fq$ then Algorithm \ref{ALGO:RESPOLY} returns a resolvent polynomial in $\poly(n^l,\log(p))$ operations. 
		\end{thm}
		
		\begin{proof}
		    We have shown already that Algorithm \ref{ALGO:RESPOLY} returns a resolvent polynomial so we only need to bound the number of operations. The degree of the composed sum of two polynomials of degree $n$ has degree $n^2$ so in each iteration of the for loop we generate a polynomial $h$ of degree bounded by $n^i$ by computing the composed sum of a polynomial of degree $n^{i-1}$ and $n$. We have seen above that we can generate the $i$-common pair polynomials within the time bound. As there are $n$ of these polynomials we can divide $h$ by these polynomials and compute the polynomial $g$ with a $gcd$ with $h$ within the time bound as well. 
		\end{proof}
		
		We are no ready to give an algorithm for factoring arbitrary polynomials deterministically under GRH. In this algorithm we focus on the factorization of polynomials $f$ over $\Fp$. As the factorization of polynomials over $\Fq$ reduces to finding roots of polynomials over $\Fp$ this restriction is not very great. This is restriction is also made in $[\citenum{ronyai1988factoring}]$ where Theorem \ref{THM:COMPAIR} was originally proved. 
				
		Algorithm \ref{ALGO:FACTOR} produces a factor of $f$ in the case that $t_0 \ominus v$ is squarefree. Algorithm \ref{ALGO:FACTOR} makes use of the following algorithms: 
		\begin{itemize}
    \item RESOLVENT\_POLY - Algorithm \ref{ALGO:RESPOLY} 
		\item PARTITION - Algorithm \ref{ALGO:PART} 
		\item NON\_FLAT - Algorithm \ref{ALGO:NONFLAT} 
		\end{itemize}
		\begin{singlespace}
		
    \begin{algorithm}[H]
		\DontPrintSemicolon
    \label{ALGO:FACTOR}	
    \caption{ALGO:FACTOR}
        Input : $p,f$ \;
				    \hspace{2mm} $p$ a prime \;
						\hspace{2mm} $f$ a squarefree polynomial in $L_n$ with $n^l < p$ \;
		    Output : a factor $h$ of $f$ \;		
				Let $l$ be the least prime dividing $n$ \;
				Construct the finite field $\Fq$ such that $q \equiv 1 \pmod l$ \;
				Construct $\omega$ a primitive $l$th root of unity in $\Fq$ \;
				$F=\prod_{i=0}^{n-1}{(X-\omega^{l-1} r_i)}$ \;
				\tcc{RESOLVENT\_POLY returns a pair of the form $(t_G,v)$} 
				$[r,v]=\textrm{RESOLVENT\_POLY}(\Fq,l,f)$ \;
				\tcc{$g$ is the set $\{t_0,\ldots,t_m\}$} 
				$g=\textrm{PARTITION}(\Fq, l, r)$ \;
        $z=t_0 \ominus v$ \;
				\tcc{$g$ is a nontrivial factor of $F$ }
				$b=\textrm{NON\_FLAT}(z,F,\Fq$) \;
				\tcc{use a substitution to construct a nontrivial factor of $f$ from $g$ }
				\tcc{$w$ is a nontrivial factor of $f$} 
				$w=b(\omega^{l-1}X)$ \;
				Return $w$ \;
		\end{algorithm}
		\end{singlespace}
		\vspace{5mm}		
			
		\begin{thm}
		\label{THM:almostRonyai}
		    Let $p$ be a prime, $f$ be a polynomial in $L_n$ over $\Fp$, and $l$ be the least prime divisor of $n$. Under GRH, Algorithm \ref{ALGO:FACTOR} factors $f$ deterministically in $\poly(n^l,\log(p))$ $\Fp$ operations. 
		\end{thm}
		
		\begin{proof}

        If $p>n^l$ then we can factor $f$ deterministically using Berlekamp's algorithm. Let the roots of $f$ be $r_0,\ldots,r_{n-1}$. Let $s=\nu_l(q-1)$. Using Theorem \ref{THM:Huang} under GRH we can construct the finite field $\Fq=\Fp[X]/(h)$ where $h$ is an irreducible factor of $\Phi_l$ and a primitive $l$th root of unity $\zeta \in \Fq$. In $\Fq$ construct the polynomials $t_G$ and $v$ using Algorithm \ref{ALGO:RESPOLY}. The polynomial $t_G$ is an $l$-cycle polynomial of degree $n(n-1)\cdots(n-l+1)$.
				
				So using Algorithm \ref{THM:PART} we can construct a $(l,s-1)$ index partition. Let $\omega$ be a primitive $l$th root of unity. Let $F=\prod_{i=0}^{n-1}{(X-\omega^{l-1} r_i)}$. As $t_G$ is an $l$-cycle polynomial the index partition consists of $l$ polynomials of degree $n(n-1)\cdots(n-l+1)/l$. Let $t_0$ be the first polynomial in this partition. The degree of $t_0$ is not divisible by $l$ so $t_0$ is not $\ominus$ balanced with respect to $F$. Hence $b=\textrm{NON\_FLAT}(z,F,p)$ is a nontrivial factor of $F$ and $w=b(\omega^{l-1}X)$ is a nontrivial factor of $f$.
				
				For the number of operations, apart from substitutions into polynomials the algorithm consists of calls to RESOLVENT\_POLY, PARTITION, NON\_FLAT, which we know can be done within the time bound from previous theorems.

		\end{proof}
		
%
% START
%
\newpage
\chapter{Conclusion}
\label{CH:Conclusion}
%
%
    We have studied the deterministic factorization of polynomials over finite fields both unconditionally and under the Riemann Hypothesis. We consider some questions for further investigation.
		
    \textbf{Question 1.} It has been known for some time that polynomials can be factored deterministically in a number of operations proportional to $S(p-1)$ under the Extended Riemann Hypothesis. In Theorem \ref{THM:CoDeg} we found that polynomials can be factored deterministically and unconditionally in a number of operations proportional to $S(p-1)$ provided that $\gcd(n,\phi(p-1))=1$. Can this requirement be weakened?
		
		Theorem 3 in [\citenum{bach2001factoring}] could potentially be useful. This theorem shows that to factor arbitrary polynomials over $\Fp$ in $\poly(\log(p),n,S(p-1))$ operations it is sufficient to find roots of $\Phi_l$ for each prime $l$ dividing $p-1$ in $\poly(\log(p),n,S(p-1))$ operations. It seems possible that the condition can at least be improved to 
		\[ \gcd \Bigl(n,\prod_{\substack{l \mid p-1 \\ \textrm{l prime} }}{\bigl(l-1 \bigr)} \Bigr)=1. \] 
		
		\textbf{Question 2.} The best algorithm for factoring generic polynomials of degree $n$ over the finite field $\mathbb{F}_{p^k}[X]$ uses 
		    \[ \log(p)\tilde{O}((nk)^2) + p^{1 / 2} \log(p) \tilde{O}((nk)^{3/2}) \] 
		\noindent $\Fp$ operations. We have considered the class of bounded degree polynomials and found that we can factor polynomials in the class deterministically and unconditionally more quickly than generic polynomials can be factored. Further improvements to the class of bounded degree polynomials may be possible. We restricted attention to the case of unconditionally and deterministically factoring bounded degree polynomials. This class could also be examined under GRH. Are there other classes of polynomials that can be factored deterministically and unconditionally more efficiently than generic polynomials? 
		
		\textbf{Question 3.} The class of cyclotomic polynomials is relevant to many results on FPFF in the literature. The ability to factor polynomials in this class unconditionally would remove the requirement of the Generalized Riemann Hypothesis from many theorems. There has been recent progress on the unconditional factorization of cyclotomic polynomials in [\citenum{ivanyos2012trading}]. However, complete factorization of generic polynomials in this class seems out of reach of current methods. For example, these polynomials do not satisfy the condition $\gcd(n,\phi(p-1))=1$ and so cannot be factored using Theorem \ref{THM:CoDeg}. Can the methods of Chapter 4 be extended to give new results on the unconditional factorization of cyclotomic polynomials?
		
		\textbf{Question 4.} The problem of constructing nonresidues is closely related to the factorization of polynomials. For example, there is a polynomial time equivalence between the problem of constructing a quadratic nonresidue and factoring degree two polynomials. Given an algorithm $\mcA$ for factoring quadratic polynomials over $\Fq$ we can construct a quadratic nonresidue by finding elements of $\Fq$ corresponding to the sequence 
		\[ (-1)^{\frac{1}{2}},(-1)^{\frac{1}{4}},\ldots,(-1)^{\frac{1}{2^{s-1}}} \]
		\noindent for $s=\nu_2(q-1)$. In the other direction, given a quadratic nonresidue we can factor any degree two polynomial using Theorem \ref{THM:rootz}. 
		From Theorem \ref{THM:COMPAIR} we have that given a finite field $\Fq$ and a field extension $\mathbb{F}_{q^k}$ of $\Fq$ so that an $l$th nonresidue is given in $\mathbb{F}_{q^k}$ we can unconditionally factor any polynomial of degree $n$ so that $l$ divides $n$ (in $\poly(\log(q),n^l) \Fp$-operations). If an algorithm $\mcA$ for completely factoring polynomials of degree $n \mid q-1$ is given, can $\mcA$ be used to construct an $n$th nonresidue in $\Fq$? 
		
		\textbf{Question 5.} In Chapter \ref{CH:uncond} and Chapter \ref{CH:ERH} we have made use of the composed quotient and product and the composed sum and difference respectively to study FPFF. Although more general frameworks for studying the factorization of polynomials over finite fields exist, the composed operations are useful because they are relatively concrete. Our use of these operations has been fairly straightforward. Can new results on FPFF be found by combining various composed operations such as the composed sum and the composed product?

%
% include unused references
%
\nocite{Cipolla}		
\nocite{pocklington1917}
\newpage		

%\addcontentsline{toc}{section}{Index}
%\printindex

\addcontentsline{toc}{section}{References}
\bibliography{ref}

\end{document}
